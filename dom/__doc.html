<html>
	<head>
		<title>Package github.com/go3d/go-collada/dom</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-collada/dom</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-collada/dom"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The go-collada/dom package provides logic-less base data structures
for all resource types used in COLLADA 1.5 or 1.4.1 documents.
</p>
<p>
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.
</p>
<p>
Context: every graphics app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.
</p>
<p>
While for all these resource types, a graphics app most likely manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go-collada/dom package.
</p>
<p>
This package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t
have to needlessly depend on the graphics, windowing etc. stacks.
</p>
<p>
NOTE: there are essentially two distinct &#34;modes&#34; or use-cases in which this package will be active:
</p>
<p>
1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.
</p>
<p>
2. in an interactive graphical app:
</p>
<p>
All &#34;Sync&#34;-related functions pertain to use-case #2, where this package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the parent package at runtime.
So now every image definition in go-collada/dom may have a corresponding GPU-bound texture object in the app,
every dom mesh definition may be bound to an app&#39;s &#34;MeshBuffer&#34; or some such construction, etc.
</p>
<p>
Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
fully consistent with the COLLADA specification in terminology and resource organization:
</p>
<p>
1. First, there is a FooDef struct for the one-time definition of a unique resource:
GeometryDef, FxImageDef, LightDef, FxMaterialDef etc.
</p>
<p>
2. Next, there is a smaller FooInst struct for handling many individual (sometimes parameterized) instantiations of
a FooDef: GeometryInst, FxImageInst, LightInst, FxMaterialInst etc.
</p>
<p>
3. Finally, there is a light-weight LibFooDefs struct type (encapsulating a typed hash-table) containing Defs
associated with their Id: LibGeometryDefs, LibFxImageDefs, LibLightDefs, LibFxMaterialDefs etc.
</p>
<p>
4. The package also provides a pre-initialized global FooDefs variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryDefs, FxImageDefs, LightDefs, FxMaterialDefs etc.
</p>
<p>
5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
AllFooDefLibs variable, essentially a hash-table of Libs: AllGeometryDefLibs (of type
LibsGeometryDef), AllFxImageDefLibs (of type LibsFxImageDef), AllLightDefLibs (of type LibsLightDef),
AllFxMaterialDefLibs (of type LibsFxMaterialDef) etc.
</p>
<p>
Any exported types in this package not following the above pattern should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#AnimSamplerBehavior">type AnimSamplerBehavior</a></dd>
				
				
			
				
				<dd><a href="#AnimationChannel">type AnimationChannel</a></dd>
				
				
			
				
				<dd><a href="#AnimationClipDef">type AnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.DefaultInst">func (me *AnimationClipDef) DefaultInst() (inst *AnimationClipInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.Init">func (me *AnimationClipDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.NewInst">func (me *AnimationClipDef) NewInst() (inst *AnimationClipInst)</a></dd>
				
			
				
				<dd><a href="#AnimationClipInst">type AnimationClipInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipInst.EnsureDef">func (me *AnimationClipInst) EnsureDef() *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipInst.Init">func (me *AnimationClipInst) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationDef">type AnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.DefaultInst">func (me *AnimationDef) DefaultInst() (inst *AnimationInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.Init">func (me *AnimationDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.NewInst">func (me *AnimationDef) NewInst() (inst *AnimationInst)</a></dd>
				
			
				
				<dd><a href="#AnimationInst">type AnimationInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationInst.EnsureDef">func (me *AnimationInst) EnsureDef() *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationInst.Init">func (me *AnimationInst) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationSampler">type AnimationSampler</a></dd>
				
				
			
				
				<dd><a href="#Asset">type Asset</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAsset">func NewAsset() (me *Asset)</a></dd>
				
				
			
				
				<dd><a href="#AssetContributor">type AssetContributor</a></dd>
				
				
			
				
				<dd><a href="#AssetGeographicLocation">type AssetGeographicLocation</a></dd>
				
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#BaseSync">type BaseSync</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetDirty">func (me *BaseSync) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetFieldB">func (me *BaseSync) SetFieldB(field *bool, val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetFieldF">func (me *BaseSync) SetFieldF(field *float64, val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SyncChanges">func (me *BaseSync) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#Bool2">type Bool2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool2.AccessIndex">func (me *Bool2) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Bool3">type Bool3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool3.AccessIndex">func (me *Bool3) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Bool4">type Bool4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool4.AccessIndex">func (me *Bool4) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.DefaultInst">func (me *CameraDef) DefaultInst() (inst *CameraInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.Init">func (me *CameraDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.NewInst">func (me *CameraDef) NewInst() (inst *CameraInst)</a></dd>
				
			
				
				<dd><a href="#CameraImager">type CameraImager</a></dd>
				
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraInst.EnsureDef">func (me *CameraInst) EnsureDef() *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraInst.Init">func (me *CameraInst) Init()</a></dd>
				
			
				
				<dd><a href="#CameraOptics">type CameraOptics</a></dd>
				
				
			
				
				<dd><a href="#CameraOrthographic">type CameraOrthographic</a></dd>
				
				
			
				
				<dd><a href="#CameraPerspective">type CameraPerspective</a></dd>
				
				
			
				
				<dd><a href="#ChildNode">type ChildNode</a></dd>
				
				
			
				
				<dd><a href="#ControllerDef">type ControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.DefaultInst">func (me *ControllerDef) DefaultInst() (inst *ControllerInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.Init">func (me *ControllerDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.NewInst">func (me *ControllerDef) NewInst() (inst *ControllerInst)</a></dd>
				
			
				
				<dd><a href="#ControllerInputs">type ControllerInputs</a></dd>
				
				
			
				
				<dd><a href="#ControllerInst">type ControllerInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerInst.EnsureDef">func (me *ControllerInst) EnsureDef() *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerInst.Init">func (me *ControllerInst) Init()</a></dd>
				
			
				
				<dd><a href="#ControllerMorph">type ControllerMorph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerMorph">func NewControllerMorph() (me *ControllerMorph)</a></dd>
				
				
			
				
				<dd><a href="#ControllerSkin">type ControllerSkin</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerSkin">func NewControllerSkin() (me *ControllerSkin)</a></dd>
				
				
			
				
				<dd><a href="#Document">type Document</a></dd>
				
				
			
				
				<dd><a href="#Extra">type Extra</a></dd>
				
				
			
				
				<dd><a href="#Float2">type Float2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float2.AccessIndex">func (me *Float2) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float2x2">type Float2x2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float2x2.AccessIndex">func (me *Float2x2) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float2x3">type Float2x3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float2x3.AccessIndex">func (me *Float2x3) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float2x4">type Float2x4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float2x4.AccessIndex">func (me *Float2x4) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float3">type Float3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float3.AccessIndex">func (me *Float3) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float3x2">type Float3x2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float3x2.AccessIndex">func (me *Float3x2) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float3x3">type Float3x3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float3x3.AccessIndex">func (me *Float3x3) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float3x4">type Float3x4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float3x4.AccessIndex">func (me *Float3x4) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float4">type Float4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float4.AccessIndex">func (me *Float4) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float4x2">type Float4x2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float4x2.AccessIndex">func (me *Float4x2) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float4x3">type Float4x3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float4x3.AccessIndex">func (me *Float4x3) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float4x4">type Float4x4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float4x4.AccessIndex">func (me *Float4x4) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Float7">type Float7</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float7.AccessIndex">func (me *Float7) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Formula">type Formula</a></dd>
				
				
			
				
				<dd><a href="#FormulaDef">type FormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.DefaultInst">func (me *FormulaDef) DefaultInst() (inst *FormulaInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.Init">func (me *FormulaDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.NewInst">func (me *FormulaDef) NewInst() (inst *FormulaInst)</a></dd>
				
			
				
				<dd><a href="#FormulaInst">type FormulaInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaInst.EnsureDef">func (me *FormulaInst) EnsureDef() *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaInst.Init">func (me *FormulaInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxAnnotation">type FxAnnotation</a></dd>
				
				
			
				
				<dd><a href="#FxBinding">type FxBinding</a></dd>
				
				
			
				
				<dd><a href="#FxColor">type FxColor</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxColor.AccessField">func (me *FxColor) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxColor.AccessIndex">func (me *FxColor) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
				
			
				
				<dd><a href="#FxCreate">type FxCreate</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2D">type FxCreate2D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeExact">type FxCreate2DSizeExact</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeRatio">type FxCreate2DSizeRatio</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3D">type FxCreate3D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3DInitFrom">type FxCreate3DInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCube">type FxCreateCube</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCubeInitFrom">type FxCreateCubeInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormat">type FxCreateFormat</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormatHint">type FxCreateFormatHint</a></dd>
				
				
			
				
				<dd><a href="#FxCreateInitFrom">type FxCreateInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateMips">type FxCreateMips</a></dd>
				
				
			
				
				<dd><a href="#FxCubeFace">type FxCubeFace</a></dd>
				
				
			
				
				<dd><a href="#FxEffectDef">type FxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.Common">func (me *FxEffectDef) Common() (prof *FxProfile)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.DefaultInst">func (me *FxEffectDef) DefaultInst() (inst *FxEffectInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.Init">func (me *FxEffectDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.NewInst">func (me *FxEffectDef) NewInst() (inst *FxEffectInst)</a></dd>
				
			
				
				<dd><a href="#FxEffectInst">type FxEffectInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectInst.EnsureDef">func (me *FxEffectInst) EnsureDef() *FxEffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectInst.Init">func (me *FxEffectInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxEffectInstTechniqueHint">type FxEffectInstTechniqueHint</a></dd>
				
				
			
				
				<dd><a href="#FxFilterKind">type FxFilterKind</a></dd>
				
				
			
				
				<dd><a href="#FxFormatChannels">type FxFormatChannels</a></dd>
				
				
			
				
				<dd><a href="#FxFormatPrecision">type FxFormatPrecision</a></dd>
				
				
			
				
				<dd><a href="#FxFormatRange">type FxFormatRange</a></dd>
				
				
			
				
				<dd><a href="#FxGlslTechniques">type FxGlslTechniques</a></dd>
				
				
			
				
				<dd><a href="#FxImageDef">type FxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.DefaultInst">func (me *FxImageDef) DefaultInst() (inst *FxImageInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.Init">func (me *FxImageDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.NewInst">func (me *FxImageDef) NewInst() (inst *FxImageInst)</a></dd>
				
			
				
				<dd><a href="#FxImageInitFrom">type FxImageInitFrom</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImageInitFrom">func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</a></dd>
				
				
			
				
				<dd><a href="#FxImageInst">type FxImageInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageInst.EnsureDef">func (me *FxImageInst) EnsureDef() *FxImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageInst.Init">func (me *FxImageInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxInitFrom">type FxInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxMaterialDef">type FxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.DefaultInst">func (me *FxMaterialDef) DefaultInst() (inst *FxMaterialInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.Init">func (me *FxMaterialDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.NewInst">func (me *FxMaterialDef) NewInst() (inst *FxMaterialInst)</a></dd>
				
			
				
				<dd><a href="#FxMaterialInst">type FxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.AccessField">func (me *FxMaterialInst) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.EnsureDef">func (me *FxMaterialInst) EnsureDef() *FxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.Init">func (me *FxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxParamDef">type FxParamDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxParamDef.AccessField">func (me *FxParamDef) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#FxParamDefs">type FxParamDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxParamDefs.Set">func (me FxParamDefs) Set(sid string, val interface{})</a></dd>
				
			
				
				<dd><a href="#FxPass">type FxPass</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPass">func NewFxPass() (me *FxPass)</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluation">type FxPassEvaluation</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearColor">type FxPassEvaluationClearColor</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearDepth">type FxPassEvaluationClearDepth</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearStencil">type FxPassEvaluationClearStencil</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationTarget">type FxPassEvaluationTarget</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPassEvaluationTarget">func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgram">type FxPassProgram</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindAttribute">type FxPassProgramBindAttribute</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindUniform">type FxPassProgramBindUniform</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShader">type FxPassProgramShader</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShaderSources">type FxPassProgramShaderSources</a></dd>
				
				
			
				
				<dd><a href="#FxPassState">type FxPassState</a></dd>
				
				
			
				
				<dd><a href="#FxProfile">type FxProfile</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProfile">func NewProfile() (me *FxProfile)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileCommon">type FxProfileCommon</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlsl">type FxProfileGlsl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxProfileGlsl">func NewFxProfileGlsl() (me *FxProfileGlsl)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlslCodeInclude">type FxProfileGlslCodeInclude</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProfileGlslCodeInclude.AccessField">func (me *FxProfileGlslCodeInclude) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#FxSampler">type FxSampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSampler">func NewFxSampler() (me *FxSampler)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerFiltering">type FxSamplerFiltering</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerImage">type FxSamplerImage</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerKind">type FxSamplerKind</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerStates">type FxSamplerStates</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSamplerStates">func NewFxSamplerStates() (me *FxSamplerStates)</a></dd>
				
				
			
				
				<dd><a href="#FxShaderStage">type FxShaderStage</a></dd>
				
				
			
				
				<dd><a href="#FxTechnique">type FxTechnique</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommon">type FxTechniqueCommon</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueGlsl">type FxTechniqueGlsl</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueKind">type FxTechniqueKind</a></dd>
				
				
			
				
				<dd><a href="#FxTexture">type FxTexture</a></dd>
				
				
			
				
				<dd><a href="#FxTextureOpaque">type FxTextureOpaque</a></dd>
				
				
			
				
				<dd><a href="#FxVertexInputBinding">type FxVertexInputBinding</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrep">type GeometryBrep</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrep">func NewGeometryBrep() (me *GeometryBrep)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepBox">type GeometryBrepBox</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCapsule">type GeometryBrepCapsule</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCircle">type GeometryBrepCircle</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCone">type GeometryBrepCone</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurve">type GeometryBrepCurve</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurves">type GeometryBrepCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCylinder">type GeometryBrepCylinder</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEdges">type GeometryBrepEdges</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEllipse">type GeometryBrepEllipse</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepFaces">type GeometryBrepFaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepHyperbola">type GeometryBrepHyperbola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepLine">type GeometryBrepLine</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbs">type GeometryBrepNurbs</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbs">func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbsSurface">type GeometryBrepNurbsSurface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbsSurface">func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepOrientation">type GeometryBrepOrientation</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepParabola">type GeometryBrepParabola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPcurves">type GeometryBrepPcurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPlane">type GeometryBrepPlane</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepShells">type GeometryBrepShells</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSolids">type GeometryBrepSolids</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSphere">type GeometryBrepSphere</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurface">type GeometryBrepSurface</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaceCurves">type GeometryBrepSurfaceCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaces">type GeometryBrepSurfaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSweptSurface">type GeometryBrepSweptSurface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryBrepSweptSurface.IsExtrusion">func (me *GeometryBrepSweptSurface) IsExtrusion() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryBrepSweptSurface.IsRevolution">func (me *GeometryBrepSweptSurface) IsRevolution() bool</a></dd>
				
			
				
				<dd><a href="#GeometryBrepTorus">type GeometryBrepTorus</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepWires">type GeometryBrepWires</a></dd>
				
				
			
				
				<dd><a href="#GeometryControlVertices">type GeometryControlVertices</a></dd>
				
				
			
				
				<dd><a href="#GeometryDef">type GeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.DefaultInst">func (me *GeometryDef) DefaultInst() (inst *GeometryInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.Init">func (me *GeometryDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.NewInst">func (me *GeometryDef) NewInst() (inst *GeometryInst)</a></dd>
				
			
				
				<dd><a href="#GeometryInst">type GeometryInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryInst.EnsureDef">func (me *GeometryInst) EnsureDef() *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryInst.Init">func (me *GeometryInst) Init()</a></dd>
				
			
				
				<dd><a href="#GeometryMesh">type GeometryMesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryMesh">func NewGeometryMesh() (me *GeometryMesh)</a></dd>
				
				
			
				
				<dd><a href="#GeometryPolygonHole">type GeometryPolygonHole</a></dd>
				
				
			
				
				<dd><a href="#GeometryPositioning">type GeometryPositioning</a></dd>
				
				
			
				
				<dd><a href="#GeometryPrimitiveKind">type GeometryPrimitiveKind</a></dd>
				
				
			
				
				<dd><a href="#GeometryPrimitives">type GeometryPrimitives</a></dd>
				
				
			
				
				<dd><a href="#GeometrySpline">type GeometrySpline</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometrySpline">func NewGeometrySpline() (me *GeometrySpline)</a></dd>
				
				
			
				
				<dd><a href="#GeometryVertices">type GeometryVertices</a></dd>
				
				
			
				
				<dd><a href="#HasAsset">type HasAsset</a></dd>
				
				
			
				
				<dd><a href="#HasExtras">type HasExtras</a></dd>
				
				
			
				
				<dd><a href="#HasFxParamDefs">type HasFxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasId">type HasId</a></dd>
				
				
			
				
				<dd><a href="#HasInputs">type HasInputs</a></dd>
				
				
			
				
				<dd><a href="#HasName">type HasName</a></dd>
				
				
			
				
				<dd><a href="#HasParamDefs">type HasParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasParamInsts">type HasParamInsts</a></dd>
				
				
			
				
				<dd><a href="#HasSid">type HasSid</a></dd>
				
				
			
				
				<dd><a href="#HasSources">type HasSources</a></dd>
				
				
			
				
				<dd><a href="#HasTechniques">type HasTechniques</a></dd>
				
				
			
				
				<dd><a href="#IndexedInputs">type IndexedInputs</a></dd>
				
				
			
				
				<dd><a href="#Input">type Input</a></dd>
				
				
			
				
				<dd><a href="#InputShared">type InputShared</a></dd>
				
				
			
				
				<dd><a href="#Int2">type Int2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int2.AccessIndex">func (me *Int2) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Int2x2">type Int2x2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int2x2.AccessIndex">func (me *Int2x2) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Int3">type Int3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int3.AccessIndex">func (me *Int3) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Int3x3">type Int3x3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int3x3.AccessIndex">func (me *Int3x3) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#Int4">type Int4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int4.AccessIndex">func (me *Int4) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Int4x4">type Int4x4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int4x4.AccessIndex">func (me *Int4x4) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#KxArticulatedSystemDef">type KxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.DefaultInst">func (me *KxArticulatedSystemDef) DefaultInst() (inst *KxArticulatedSystemInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.Init">func (me *KxArticulatedSystemDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.NewInst">func (me *KxArticulatedSystemDef) NewInst() (inst *KxArticulatedSystemInst)</a></dd>
				
			
				
				<dd><a href="#KxArticulatedSystemInst">type KxArticulatedSystemInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemInst.EnsureDef">func (me *KxArticulatedSystemInst) EnsureDef() *KxArticulatedSystemDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemInst.Init">func (me *KxArticulatedSystemInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxAttachment">type KxAttachment</a></dd>
				
				
			
				
				<dd><a href="#KxAttachmentKind">type KxAttachmentKind</a></dd>
				
				
			
				
				<dd><a href="#KxAxisIndex">type KxAxisIndex</a></dd>
				
				
			
				
				<dd><a href="#KxAxisLimits">type KxAxisLimits</a></dd>
				
				
			
				
				<dd><a href="#KxBinding">type KxBinding</a></dd>
				
				
			
				
				<dd><a href="#KxEffector">type KxEffector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxEffector">func NewKxEffector() (me *KxEffector)</a></dd>
				
				
			
				
				<dd><a href="#KxFrame">type KxFrame</a></dd>
				
				
			
				
				<dd><a href="#KxFrameObject">type KxFrameObject</a></dd>
				
				
			
				
				<dd><a href="#KxFrameOrigin">type KxFrameOrigin</a></dd>
				
				
			
				
				<dd><a href="#KxFrameTcp">type KxFrameTcp</a></dd>
				
				
			
				
				<dd><a href="#KxFrameTip">type KxFrameTip</a></dd>
				
				
			
				
				<dd><a href="#KxJoint">type KxJoint</a></dd>
				
				
			
				
				<dd><a href="#KxJointAxisBinding">type KxJointAxisBinding</a></dd>
				
				
			
				
				<dd><a href="#KxJointDef">type KxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.DefaultInst">func (me *KxJointDef) DefaultInst() (inst *KxJointInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.Init">func (me *KxJointDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.NewInst">func (me *KxJointDef) NewInst() (inst *KxJointInst)</a></dd>
				
			
				
				<dd><a href="#KxJointInst">type KxJointInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointInst.EnsureDef">func (me *KxJointInst) EnsureDef() *KxJointDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointInst.Init">func (me *KxJointInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxJointKind">type KxJointKind</a></dd>
				
				
			
				
				<dd><a href="#KxJointLimits">type KxJointLimits</a></dd>
				
				
			
				
				<dd><a href="#KxKinematicsAxis">type KxKinematicsAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxKinematicsAxis">func NewKxKinematicsAxis() (me *KxKinematicsAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxKinematicsSystem">type KxKinematicsSystem</a></dd>
				
				
			
				
				<dd><a href="#KxLink">type KxLink</a></dd>
				
				
			
				
				<dd><a href="#KxModelBinding">type KxModelBinding</a></dd>
				
				
			
				
				<dd><a href="#KxModelDef">type KxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.DefaultInst">func (me *KxModelDef) DefaultInst() (inst *KxModelInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.Init">func (me *KxModelDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.NewInst">func (me *KxModelDef) NewInst() (inst *KxModelInst)</a></dd>
				
			
				
				<dd><a href="#KxModelInst">type KxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelInst.EnsureDef">func (me *KxModelInst) EnsureDef() *KxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelInst.Init">func (me *KxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxMotionAxis">type KxMotionAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxMotionAxis">func NewKxMotionAxis() (me *KxMotionAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxMotionSystem">type KxMotionSystem</a></dd>
				
				
			
				
				<dd><a href="#KxSceneDef">type KxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.DefaultInst">func (me *KxSceneDef) DefaultInst() (inst *KxSceneInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.Init">func (me *KxSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.NewInst">func (me *KxSceneDef) NewInst() (inst *KxSceneInst)</a></dd>
				
			
				
				<dd><a href="#KxSceneInst">type KxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneInst.EnsureDef">func (me *KxSceneInst) EnsureDef() *KxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneInst.Init">func (me *KxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#Layers">type Layers</a></dd>
				
				
			
				
				<dd><a href="#LibAnimationClipDefs">type LibAnimationClipDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Add">func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.AddNew">func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Len">func (me *LibAnimationClipDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.New">func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Remove">func (me *LibAnimationClipDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.SyncChanges">func (me *LibAnimationClipDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibAnimationDefs">type LibAnimationDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Add">func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.AddNew">func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Len">func (me *LibAnimationDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.New">func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Remove">func (me *LibAnimationDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.SyncChanges">func (me *LibAnimationDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Len">func (me *LibCameraDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibControllerDefs">type LibControllerDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Add">func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.AddNew">func (me *LibControllerDefs) AddNew(id string) *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Len">func (me *LibControllerDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.New">func (me *LibControllerDefs) New(id string) (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Remove">func (me *LibControllerDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.SyncChanges">func (me *LibControllerDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFormulaDefs">type LibFormulaDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Add">func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.AddNew">func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Len">func (me *LibFormulaDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.New">func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Remove">func (me *LibFormulaDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.SyncChanges">func (me *LibFormulaDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxEffectDefs">type LibFxEffectDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Add">func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.AddNew">func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Len">func (me *LibFxEffectDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.New">func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Remove">func (me *LibFxEffectDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.SyncChanges">func (me *LibFxEffectDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxImageDefs">type LibFxImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Add">func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.AddNew">func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Len">func (me *LibFxImageDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.New">func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Remove">func (me *LibFxImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.SyncChanges">func (me *LibFxImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxMaterialDefs">type LibFxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Add">func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.AddNew">func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Len">func (me *LibFxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.New">func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Remove">func (me *LibFxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.SyncChanges">func (me *LibFxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibGeometryDefs">type LibGeometryDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Add">func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.AddNew">func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Len">func (me *LibGeometryDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.New">func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Remove">func (me *LibGeometryDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.SyncChanges">func (me *LibGeometryDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxArticulatedSystemDefs">type LibKxArticulatedSystemDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Add">func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.AddNew">func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Len">func (me *LibKxArticulatedSystemDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.New">func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Remove">func (me *LibKxArticulatedSystemDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.SyncChanges">func (me *LibKxArticulatedSystemDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxJointDefs">type LibKxJointDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Add">func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.AddNew">func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Len">func (me *LibKxJointDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.New">func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Remove">func (me *LibKxJointDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.SyncChanges">func (me *LibKxJointDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxModelDefs">type LibKxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Add">func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.AddNew">func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Len">func (me *LibKxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.New">func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Remove">func (me *LibKxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.SyncChanges">func (me *LibKxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxSceneDefs">type LibKxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Add">func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.AddNew">func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Len">func (me *LibKxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.New">func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Remove">func (me *LibKxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.SyncChanges">func (me *LibKxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibLightDefs">type LibLightDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Add">func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.AddNew">func (me *LibLightDefs) AddNew(id string) *LightDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Len">func (me *LibLightDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.New">func (me *LibLightDefs) New(id string) (def *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Remove">func (me *LibLightDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.SyncChanges">func (me *LibLightDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Len">func (me *LibNodeDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxForceFieldDefs">type LibPxForceFieldDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Add">func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.AddNew">func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Len">func (me *LibPxForceFieldDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.New">func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Remove">func (me *LibPxForceFieldDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.SyncChanges">func (me *LibPxForceFieldDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxMaterialDefs">type LibPxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Add">func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.AddNew">func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Len">func (me *LibPxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.New">func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Remove">func (me *LibPxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.SyncChanges">func (me *LibPxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxModelDefs">type LibPxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Add">func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.AddNew">func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Len">func (me *LibPxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.New">func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Remove">func (me *LibPxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.SyncChanges">func (me *LibPxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxSceneDefs">type LibPxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Add">func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.AddNew">func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Len">func (me *LibPxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.New">func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Remove">func (me *LibPxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.SyncChanges">func (me *LibPxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Len">func (me *LibVisualSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsAnimationClipDef">type LibsAnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationClipDef.AddNew">func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</a></dd>
				
			
				
				<dd><a href="#LibsAnimationDef">type LibsAnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationDef.AddNew">func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsControllerDef">type LibsControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsControllerDef.AddNew">func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFormulaDef">type LibsFormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFormulaDef.AddNew">func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxEffectDef">type LibsFxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxEffectDef.AddNew">func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxImageDef">type LibsFxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxImageDef.AddNew">func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxMaterialDef">type LibsFxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxMaterialDef.AddNew">func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsGeometryDef">type LibsGeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsGeometryDef.AddNew">func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxArticulatedSystemDef">type LibsKxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxArticulatedSystemDef.AddNew">func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxJointDef">type LibsKxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxJointDef.AddNew">func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxModelDef">type LibsKxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxModelDef.AddNew">func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxSceneDef">type LibsKxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxSceneDef.AddNew">func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsLightDef">type LibsLightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsLightDef.AddNew">func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxForceFieldDef">type LibsPxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxForceFieldDef.AddNew">func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxMaterialDef">type LibsPxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxMaterialDef.AddNew">func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxModelDef">type LibsPxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxModelDef.AddNew">func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxSceneDef">type LibsPxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxSceneDef.AddNew">func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LightAmbient">type LightAmbient</a></dd>
				
				
			
				
				<dd><a href="#LightAttenuation">type LightAttenuation</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightAttenuation">func NewLightAttenuation() (me *LightAttenuation)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightAttenuation.AccessField">func (me *LightAttenuation) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#LightBase">type LightBase</a></dd>
				
				
			
				
				<dd><a href="#LightDef">type LightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.DefaultInst">func (me *LightDef) DefaultInst() (inst *LightInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.Init">func (me *LightDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.NewInst">func (me *LightDef) NewInst() (inst *LightInst)</a></dd>
				
			
				
				<dd><a href="#LightDirectional">type LightDirectional</a></dd>
				
				
			
				
				<dd><a href="#LightInst">type LightInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightInst.EnsureDef">func (me *LightInst) EnsureDef() *LightDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LightInst.Init">func (me *LightInst) Init()</a></dd>
				
			
				
				<dd><a href="#LightPoint">type LightPoint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightPoint">func NewLightPoint() (me *LightPoint)</a></dd>
				
				
			
				
				<dd><a href="#LightSpot">type LightSpot</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightSpot">func NewLightSpot() (me *LightSpot)</a></dd>
				
				
			
				
				<dd><a href="#MaterialBinding">type MaterialBinding</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.AccessField">func (me *NodeDef) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.DefaultInst">func (me *NodeDef) DefaultInst() (inst *NodeInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.Init">func (me *NodeDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.NewInst">func (me *NodeDef) NewInst() (inst *NodeInst)</a></dd>
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.AccessField">func (me *NodeInst) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.EnsureDef">func (me *NodeInst) EnsureDef() *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.Init">func (me *NodeInst) Init()</a></dd>
				
			
				
				<dd><a href="#Param">type Param</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Param.AccessField">func (me *Param) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#ParamDef">type ParamDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParamDef.AccessField">func (me *ParamDef) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#ParamDefs">type ParamDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParamDefs.Set">func (me ParamDefs) Set(sid string, val interface{})</a></dd>
				
			
				
				<dd><a href="#ParamInst">type ParamInst</a></dd>
				
				
			
				
				<dd><a href="#ParamInsts">type ParamInsts</a></dd>
				
				
			
				
				<dd><a href="#ParamOrBool">type ParamOrBool</a></dd>
				
				
			
				
				<dd><a href="#ParamOrFloat">type ParamOrFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamOrFloat2">type ParamOrFloat2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParamOrFloat2.AccessIndex">func (me *ParamOrFloat2) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#ParamOrInt">type ParamOrInt</a></dd>
				
				
			
				
				<dd><a href="#ParamOrRefSid">type ParamOrRefSid</a></dd>
				
				
			
				
				<dd><a href="#ParamOrSidFloat">type ParamOrSidFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamOrUint">type ParamOrUint</a></dd>
				
				
			
				
				<dd><a href="#PxCylinder">type PxCylinder</a></dd>
				
				
			
				
				<dd><a href="#PxForceFieldDef">type PxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.DefaultInst">func (me *PxForceFieldDef) DefaultInst() (inst *PxForceFieldInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.Init">func (me *PxForceFieldDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.NewInst">func (me *PxForceFieldDef) NewInst() (inst *PxForceFieldInst)</a></dd>
				
			
				
				<dd><a href="#PxForceFieldInst">type PxForceFieldInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldInst.EnsureDef">func (me *PxForceFieldInst) EnsureDef() *PxForceFieldDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldInst.Init">func (me *PxForceFieldInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxMaterial">type PxMaterial</a></dd>
				
				
			
				
				<dd><a href="#PxMaterialDef">type PxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.DefaultInst">func (me *PxMaterialDef) DefaultInst() (inst *PxMaterialInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.Init">func (me *PxMaterialDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.NewInst">func (me *PxMaterialDef) NewInst() (inst *PxMaterialInst)</a></dd>
				
			
				
				<dd><a href="#PxMaterialInst">type PxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialInst.EnsureDef">func (me *PxMaterialInst) EnsureDef() *PxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialInst.Init">func (me *PxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxModelDef">type PxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.DefaultInst">func (me *PxModelDef) DefaultInst() (inst *PxModelInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.Init">func (me *PxModelDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.NewInst">func (me *PxModelDef) NewInst() (inst *PxModelInst)</a></dd>
				
			
				
				<dd><a href="#PxModelInst">type PxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.AccessField">func (me *PxModelInst) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.EnsureDef">func (me *PxModelInst) EnsureDef() *PxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.Init">func (me *PxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyCommon">type PxRigidBodyCommon</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyCommon.AccessField">func (me *PxRigidBodyCommon) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyDef">type PxRigidBodyDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyDef.Init">func (me *PxRigidBodyDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyDefs">type PxRigidBodyDefs</a></dd>
				
				
			
				
				<dd><a href="#PxRigidBodyInst">type PxRigidBodyInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyInst.AccessField">func (me *PxRigidBodyInst) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyInst.Init">func (me *PxRigidBodyInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintAttachment">type PxRigidConstraintAttachment</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintDef">type PxRigidConstraintDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintDef.Init">func (me *PxRigidConstraintDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintDefs">type PxRigidConstraintDefs</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintInst">type PxRigidConstraintInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintInst.Init">func (me *PxRigidConstraintInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintLimit">type PxRigidConstraintLimit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintLimit.AccessField">func (me *PxRigidConstraintLimit) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintSpring">type PxRigidConstraintSpring</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPxRigidConstraintSpring">func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintSpring.AccessField">func (me *PxRigidConstraintSpring) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#PxSceneDef">type PxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.DefaultInst">func (me *PxSceneDef) DefaultInst() (inst *PxSceneInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.Init">func (me *PxSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.NewInst">func (me *PxSceneDef) NewInst() (inst *PxSceneInst)</a></dd>
				
			
				
				<dd><a href="#PxSceneInst">type PxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneInst.EnsureDef">func (me *PxSceneInst) EnsureDef() *PxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneInst.Init">func (me *PxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxShape">type PxShape</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxShape.AccessField">func (me *PxShape) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#RefId">type RefId</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationClipDef">func (me RefId) AnimationClipDef() (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationDef">func (me RefId) AnimationDef() (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationSampler">func (me RefId) AnimationSampler() (as *AnimationSampler)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInAnimationDef">func (me RefId) ArrayInAnimationDef() *SourceArray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInAnyDef">func (me RefId) ArrayInAnyDef() (srcArr *SourceArray)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInControllerDef">func (me RefId) ArrayInControllerDef() *SourceArray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInGeometryDef">func (me RefId) ArrayInGeometryDef() (sa *SourceArray)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.CameraDef">func (me RefId) CameraDef() (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ControllerDef">func (me RefId) ControllerDef() (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FormulaDef">func (me RefId) FormulaDef() (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxEffectDef">func (me RefId) FxEffectDef() (def *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxImageDef">func (me RefId) FxImageDef() (def *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxMaterialDef">func (me RefId) FxMaterialDef() (def *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxProfile">func (me RefId) FxProfile() (fp *FxProfile)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxTechniqueCommon">func (me RefId) FxTechniqueCommon() *FxTechniqueCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxTechniqueGlsl">func (me RefId) FxTechniqueGlsl() (t *FxTechniqueGlsl)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepEdges">func (me RefId) GeometryBrepEdges() *GeometryBrepEdges</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepFaces">func (me RefId) GeometryBrepFaces() *GeometryBrepFaces</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepPcurves">func (me RefId) GeometryBrepPcurves() *GeometryBrepPcurves</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepShells">func (me RefId) GeometryBrepShells() *GeometryBrepShells</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepSolids">func (me RefId) GeometryBrepSolids() *GeometryBrepSolids</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepWires">func (me RefId) GeometryBrepWires() *GeometryBrepWires</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryDef">func (me RefId) GeometryDef() (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryMesh">func (me RefId) GeometryMesh() (gm *GeometryMesh)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryVertices">func (me RefId) GeometryVertices() *GeometryVertices</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxArticulatedSystemDef">func (me RefId) KxArticulatedSystemDef() (def *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxJointDef">func (me RefId) KxJointDef() (def *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxModelDef">func (me RefId) KxModelDef() (def *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxSceneDef">func (me RefId) KxSceneDef() (def *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.LightDef">func (me RefId) LightDef() (def *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.NodeDef">func (me RefId) NodeDef() (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxForceFieldDef">func (me RefId) PxForceFieldDef() (def *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxMaterialDef">func (me RefId) PxMaterialDef() (def *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxModelDef">func (me RefId) PxModelDef() (def *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxSceneDef">func (me RefId) PxSceneDef() (def *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.S">func (me RefId) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SetIdRef">func (me *RefId) SetIdRef(v string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInAnimationDef">func (me RefId) SourceInAnimationDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInAnyDef">func (me RefId) SourceInAnyDef() (src *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInControllerDef">func (me RefId) SourceInControllerDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInGeometryDef">func (me RefId) SourceInGeometryDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.VisualSceneDef">func (me RefId) VisualSceneDef() (def *VisualSceneDef)</a></dd>
				
			
				
				<dd><a href="#RefParam">type RefParam</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRefParam">func NewRefParam(paramRef string) (rs *RefParam)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.SetParamRef">func (me *RefParam) SetParamRef(sidRef string)</a></dd>
				
			
				
				<dd><a href="#RefSid">type RefSid</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRefSid">func NewRefSid(sidRef string) (rs *RefSid)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.Resolve">func (me *RefSid) Resolve(root RefSidRoot, force bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.SetSidRef">func (me *RefSid) SetSidRef(sidRef string)</a></dd>
				
			
				
				<dd><a href="#RefSidFielder">type RefSidFielder</a></dd>
				
				
			
				
				<dd><a href="#RefSidIndexer">type RefSidIndexer</a></dd>
				
				
			
				
				<dd><a href="#RefSidRoot">type RefSidRoot</a></dd>
				
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
			
				
				<dd><a href="#SidBool">type SidBool</a></dd>
				
				
			
				
				<dd><a href="#SidFloat">type SidFloat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SidF">func SidF(f float64) (sf *SidFloat)</a></dd>
				
				
			
				
				<dd><a href="#SidFloat3">type SidFloat3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SidFloat3.AccessIndex">func (me *SidFloat3) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#SidString">type SidString</a></dd>
				
				
			
				
				<dd><a href="#SidVec3">type SidVec3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SidVec3.AccessField">func (me *SidVec3) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SidVec3.AccessIndex">func (me *SidVec3) AccessIndex(i, _ int) interface{}</a></dd>
				
			
				
				<dd><a href="#Source">type Source</a></dd>
				
				
			
				
				<dd><a href="#SourceAccessor">type SourceAccessor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSourceAccessor">func NewSourceAccessor() (me *SourceAccessor)</a></dd>
				
				
			
				
				<dd><a href="#SourceArray">type SourceArray</a></dd>
				
				
			
				
				<dd><a href="#Sources">type Sources</a></dd>
				
				
			
				
				<dd><a href="#Technique">type Technique</a></dd>
				
				
			
				
				<dd><a href="#Transform">type Transform</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Transform.AccessField">func (me *Transform) AccessField(fn string) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Transform.AccessIndex">func (me *Transform) AccessIndex(i, j int) interface{}</a></dd>
				
			
				
				<dd><a href="#TransformKind">type TransformKind</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.DefaultInst">func (me *VisualSceneDef) DefaultInst() (inst *VisualSceneInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.Init">func (me *VisualSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.NewInst">func (me *VisualSceneDef) NewInst() (inst *VisualSceneInst)</a></dd>
				
			
				
				<dd><a href="#VisualSceneEvaluation">type VisualSceneEvaluation</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneEvaluation.AccessField">func (me *VisualSceneEvaluation) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneInst.EnsureDef">func (me *VisualSceneInst) EnsureDef() *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneInst.Init">func (me *VisualSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#VisualSceneRendering">type VisualSceneRendering</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewVisualSceneRendering">func NewVisualSceneRendering() (me *VisualSceneRendering)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneRendering.AccessField">func (me *VisualSceneRendering) AccessField(fn string) interface{}</a></dd>
				
			
				
				<dd><a href="#VisualSceneRenderingMaterialInst">type VisualSceneRenderingMaterialInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-gen-refsids.go">-gen-refsids.go</a>
			
				<a href="/target/animation.gt.go">animation.gt.go</a>
			
				<a href="/target/animationclip.gt.go">animationclip.gt.go</a>
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/common.go">common.go</a>
			
				<a href="/target/controller.gt.go">controller.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/formula.gt.go">formula.gt.go</a>
			
				<a href="/target/fxeffect.gt.go">fxeffect.gt.go</a>
			
				<a href="/target/fximage.gt.go">fximage.gt.go</a>
			
				<a href="/target/fxmaterial.gt.go">fxmaterial.gt.go</a>
			
				<a href="/target/fxsampler.go">fxsampler.go</a>
			
				<a href="/target/geometry.gt.go">geometry.gt.go</a>
			
				<a href="/target/geometrybrep.go">geometrybrep.go</a>
			
				<a href="/target/kxarticulatedsystem.gt.go">kxarticulatedsystem.gt.go</a>
			
				<a href="/target/kxjoint.gt.go">kxjoint.gt.go</a>
			
				<a href="/target/kxmodel.gt.go">kxmodel.gt.go</a>
			
				<a href="/target/kxscene.gt.go">kxscene.gt.go</a>
			
				<a href="/target/light.gt.go">light.gt.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/pxforcefield.gt.go">pxforcefield.gt.go</a>
			
				<a href="/target/pxmaterial.gt.go">pxmaterial.gt.go</a>
			
				<a href="/target/pxmodel.gt.go">pxmodel.gt.go</a>
			
				<a href="/target/pxrigidbody.go">pxrigidbody.go</a>
			
				<a href="/target/pxrigidconstraint.go">pxrigidconstraint.go</a>
			
				<a href="/target/pxscene.gt.go">pxscene.gt.go</a>
			
				<a href="/target/refid.go">refid.go</a>
			
				<a href="/target/refsid.go">refsid.go</a>
			
				<a href="/target/source.go">source.go</a>
			
				<a href="/target/transform.go">transform.go</a>
			
				<a href="/target/types.go">types.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibAnimationDefs libraries associated by their Id.</span>
    AllAnimationDefLibs = LibsAnimationDef{}

    <span class="comment">//	The &#34;default&#34; LibAnimationDefs library for AnimationDefs.</span>
    AnimationDefs = AllAnimationDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibAnimationClipDefs libraries associated by their Id.</span>
    AllAnimationClipDefLibs = LibsAnimationClipDef{}

    <span class="comment">//	The &#34;default&#34; LibAnimationClipDefs library for AnimationClipDefs.</span>
    AnimationClipDefs = AllAnimationClipDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	This callback, set by the core package (or your custom package),</span>
    <span class="comment">//	gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()

    <span class="comment">//	This callback, set by the core package (or your custom package),</span>
    <span class="comment">//	gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibCameraDefs libraries associated by their Id.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; LibCameraDefs library for CameraDefs.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibControllerDefs libraries associated by their Id.</span>
    AllControllerDefLibs = LibsControllerDef{}

    <span class="comment">//	The &#34;default&#34; LibControllerDefs library for ControllerDefs.</span>
    ControllerDefs = AllControllerDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFormulaDefs libraries associated by their Id.</span>
    AllFormulaDefLibs = LibsFormulaDef{}

    <span class="comment">//	The &#34;default&#34; LibFormulaDefs library for FormulaDefs.</span>
    FormulaDefs = AllFormulaDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxEffectDefs libraries associated by their Id.</span>
    AllFxEffectDefLibs = LibsFxEffectDef{}

    <span class="comment">//	The &#34;default&#34; LibFxEffectDefs library for FxEffectDefs.</span>
    FxEffectDefs = AllFxEffectDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxImageDefs libraries associated by their Id.</span>
    AllFxImageDefLibs = LibsFxImageDef{}

    <span class="comment">//	The &#34;default&#34; LibFxImageDefs library for FxImageDefs.</span>
    FxImageDefs = AllFxImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxMaterialDefs libraries associated by their Id.</span>
    AllFxMaterialDefLibs = LibsFxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; LibFxMaterialDefs library for FxMaterialDefs.</span>
    FxMaterialDefs = AllFxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	Default texture minification, magnification and MIP-mapping.</span>
    DefaultFxSamplerFiltering = &amp;FxSamplerFiltering{
        FilterMag:     FxFilterKindLinear,
        FilterMin:     FxFilterKindLinear,
        FilterMip:     FxFilterKindLinear,
        MaxAnisotropy: 1,
    }
    <span class="comment">//	Default texture repeating and clamping.</span>
    DefaultFxSamplerWrapping = &amp;ugfx.SamplerWrapping{
        BorderColor: ugfx.Rgba32{R: 0, G: 0, B: 0, A: 1},
        WrapS:       ugfx.WrapKindRepeat,
        WrapT:       ugfx.WrapKindRepeat,
        WrapP:       ugfx.WrapKindRepeat,
    }
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibGeometryDefs libraries associated by their Id.</span>
    AllGeometryDefLibs = LibsGeometryDef{}

    <span class="comment">//	The &#34;default&#34; LibGeometryDefs library for GeometryDefs.</span>
    GeometryDefs = AllGeometryDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxArticulatedSystemDefs libraries associated by their Id.</span>
    AllKxArticulatedSystemDefLibs = LibsKxArticulatedSystemDef{}

    <span class="comment">//	The &#34;default&#34; LibKxArticulatedSystemDefs library for KxArticulatedSystemDefs.</span>
    KxArticulatedSystemDefs = AllKxArticulatedSystemDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxJointDefs libraries associated by their Id.</span>
    AllKxJointDefLibs = LibsKxJointDef{}

    <span class="comment">//	The &#34;default&#34; LibKxJointDefs library for KxJointDefs.</span>
    KxJointDefs = AllKxJointDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxModelDefs libraries associated by their Id.</span>
    AllKxModelDefLibs = LibsKxModelDef{}

    <span class="comment">//	The &#34;default&#34; LibKxModelDefs library for KxModelDefs.</span>
    KxModelDefs = AllKxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxSceneDefs libraries associated by their Id.</span>
    AllKxSceneDefLibs = LibsKxSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibKxSceneDefs library for KxSceneDefs.</span>
    KxSceneDefs = AllKxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibLightDefs libraries associated by their Id.</span>
    AllLightDefLibs = LibsLightDef{}

    <span class="comment">//	The &#34;default&#34; LibLightDefs library for LightDefs.</span>
    LightDefs = AllLightDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibNodeDefs libraries associated by their Id.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; LibNodeDefs library for NodeDefs.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxForceFieldDefs libraries associated by their Id.</span>
    AllPxForceFieldDefLibs = LibsPxForceFieldDef{}

    <span class="comment">//	The &#34;default&#34; LibPxForceFieldDefs library for PxForceFieldDefs.</span>
    PxForceFieldDefs = AllPxForceFieldDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxMaterialDefs libraries associated by their Id.</span>
    AllPxMaterialDefLibs = LibsPxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; LibPxMaterialDefs library for PxMaterialDefs.</span>
    PxMaterialDefs = AllPxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxModelDefs libraries associated by their Id.</span>
    AllPxModelDefLibs = LibsPxModelDef{}

    <span class="comment">//	The &#34;default&#34; LibPxModelDefs library for PxModelDefs.</span>
    PxModelDefs = AllPxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxSceneDefs libraries associated by their Id.</span>
    AllPxSceneDefLibs = LibsPxSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibPxSceneDefs library for PxSceneDefs.</span>
    PxSceneDefs = AllPxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibVisualSceneDefs libraries associated by their Id.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibVisualSceneDefs library for VisualSceneDefs.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=987:1005#L32">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to the core package (or your custom package) that changes have been made that need to be
picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="AnimSamplerBehavior">type <a href="/target/animation.gt.go?s=76:104#L1">AnimSamplerBehavior</a></h2>
			<pre>type AnimSamplerBehavior int</pre>
			<p>
Categorizes the possible behaviors for animation samplers.
</p>


			
				<pre>const (
    <span class="comment">//	The before and after behaviors are not defined.</span>
    AnimSamplerBehaviorUndefined AnimSamplerBehavior = iota

    <span class="comment">//	The value for the first (PreBehavior) or last (PostBehavior) is returned.</span>
    AnimSamplerBehaviorConstant

    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation cycles.</span>
    AnimSamplerBehaviorCycle

    <span class="comment">//	The animation continues indefinitely.</span>
    AnimSamplerBehaviorCycleRelative

    <span class="comment">//	The value follows the line given by the last two keys in the sample.</span>
    AnimSamplerBehaviorGradient

    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation oscillates.</span>
    AnimSamplerBehaviorOscillate
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="AnimationChannel">type <a href="/target/animation.gt.go?s=805:983#L17">AnimationChannel</a></h2>
			<pre>type AnimationChannel struct {
    <span class="comment">//	Refers to the source animation sampler.</span>
    Source RefId

    <span class="comment">//	Refers to the resource property bound to the output of the sampler.</span>
    Target RefSid
}</pre>
			<p>
Declares an output channel of an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AnimationClipDef">type <a href="/target/animationclip.gt.go?s=125:493#L1">AnimationClipDef</a></h2>
			<pre>type AnimationClipDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	The time in seconds of the beginning of the clip.</span>
    Start float64

    <span class="comment">//	The time in seconds of the end of the clip.</span>
    End float64

    <span class="comment">//	The animation instances contributing to this animation clip.</span>
    Animations []*AnimationInst

    <span class="comment">//	Any formulas used in this animation clip.</span>
    Formulas []*FormulaInst
}</pre>
			<p>
Defines a section of a set of animation curves and/or formulas
to be used together as an animation clip.
</p>


			

			

			

			

			
				
				<h3 id="AnimationClipDef.DefaultInst">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=1384:1451#L44">DefaultInst</a></h3>
				<pre>func (me *AnimationClipDef) DefaultInst() (inst *AnimationClipInst)</pre>
				<p>
Returns &#34;the default AnimationClipInst instance&#34; referencing this AnimationClipDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="AnimationClipDef.Init">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=513:547#L13">Init</a></h3>
				<pre>func (me *AnimationClipDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="AnimationClipDef.NewInst">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=1778:1841#L54">NewInst</a></h3>
				<pre>func (me *AnimationClipDef) NewInst() (inst *AnimationClipInst)</pre>
				<p>
Creates and returns a new AnimationClipInst instance referencing this AnimationClipDef definition.
Any AnimationClipInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="AnimationClipInst">type <a href="/target/animationclip.gt.go?s=597:917#L17">AnimationClipInst</a></h2>
			<pre>type AnimationClipInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *AnimationClipDef
}</pre>
			<p>
Instantiates an animation clip resource.
</p>


			

			

			

			

			
				
				<h3 id="AnimationClipInst.EnsureDef">func (*AnimationClipInst) <a href="/target/animationclip.gt.go?s=2235:2293#L65">EnsureDef</a></h3>
				<pre>func (me *AnimationClipInst) EnsureDef() *AnimationClipDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct AnimationClipDef
according to the current me.DefRef value (by searching AllAnimationClipDefLibs).
Then returns me.Def.
(Note, every AnimationClipInst&#39;s Def is nil initially, unless it was created via AnimationClipDef.NewInst().)
</p>

				
				
			
				
				<h3 id="AnimationClipInst.Init">func (*AnimationClipInst) <a href="/target/animationclip.gt.go?s=937:972#L28">Init</a></h3>
				<pre>func (me *AnimationClipInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationDef">type <a href="/target/animation.gt.go?s=1716:2082#L44">AnimationDef</a></h2>
			<pre>type AnimationDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Allows the formation of a hierarchy of related animations.</span>
    AnimationDefs []*AnimationDef

    <span class="comment">//	Describes output channels for the animation.</span>
    Channels []*AnimationChannel

    <span class="comment">//	Describes the interpolation sampling functions for the animation.</span>
    Samplers []*AnimationSampler
}</pre>
			<p>
Categorizes the declaration of animation information.
</p>


			

			

			

			

			
				
				<h3 id="AnimationDef.DefaultInst">func (*AnimationDef) <a href="/target/animation.gt.go?s=2952:3011#L94">DefaultInst</a></h3>
				<pre>func (me *AnimationDef) DefaultInst() (inst *AnimationInst)</pre>
				<p>
Returns &#34;the default AnimationInst instance&#34; referencing this AnimationDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="AnimationDef.Init">func (*AnimationDef) <a href="/target/animation.gt.go?s=2102:2132#L62">Init</a></h3>
				<pre>func (me *AnimationDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="AnimationDef.NewInst">func (*AnimationDef) <a href="/target/animation.gt.go?s=3318:3373#L104">NewInst</a></h3>
				<pre>func (me *AnimationDef) NewInst() (inst *AnimationInst)</pre>
				<p>
Creates and returns a new AnimationInst instance referencing this AnimationDef definition.
Any AnimationInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="AnimationInst">type <a href="/target/animation.gt.go?s=2201:2513#L67">AnimationInst</a></h2>
			<pre>type AnimationInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *AnimationDef
}</pre>
			<p>
Instantiates an Animation resource.
</p>


			

			

			

			

			
				
				<h3 id="AnimationInst.EnsureDef">func (*AnimationInst) <a href="/target/animation.gt.go?s=3747:3797#L115">EnsureDef</a></h3>
				<pre>func (me *AnimationInst) EnsureDef() *AnimationDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct AnimationDef
according to the current me.DefRef value (by searching AllAnimationDefLibs).
Then returns me.Def.
(Note, every AnimationInst&#39;s Def is nil initially, unless it was created via AnimationDef.NewInst().)
</p>

				
				
			
				
				<h3 id="AnimationInst.Init">func (*AnimationInst) <a href="/target/animation.gt.go?s=2533:2564#L78">Init</a></h3>
				<pre>func (me *AnimationInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationSampler">type <a href="/target/animation.gt.go?s=1050:1657#L26">AnimationSampler</a></h2>
			<pre>type AnimationSampler struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Inputs. These describe sampling points.</span>
    <span class="comment">//	At least one of the Inputs must have its Semantic set to &#34;INTERPOLATION&#34;.</span>
    HasInputs

    <span class="comment">//	Indicates what the sampled value should be before the first key.</span>
    <span class="comment">//	Must be one of the AnimSamplerBehavior* enumerated constants (defaulting to AnimSamplerBehaviorUndefined).</span>
    PreBehavior AnimSamplerBehavior

    <span class="comment">//	Indicates what the sampled value should be after the last key.</span>
    <span class="comment">//	Must be one of the AnimSamplerBehavior* enumerated constants (defaulting to AnimSamplerBehaviorUndefined).</span>
    PostBehavior AnimSamplerBehavior
}</pre>
			<p>
Declares an interpolation sampling function for an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Asset">type <a href="/target/common.go?s=2085:3338#L68">Asset</a></h2>
			<pre>type Asset struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Contains the date and time that the parent element was created.</span>
    Created string

    <span class="comment">//	Contains the date and time that the parent element was last modified.</span>
    Modified string

    <span class="comment">//	Contains a list of words used as search criteria.</span>
    Keywords string

    <span class="comment">//	Contains revision information.</span>
    Revision string

    <span class="comment">//	Contains a description of the topical subject.</span>
    Subject string

    <span class="comment">//	Contains title information.</span>
    Title string

    <span class="comment">//	Contains descriptive information about the coordinate system of the geometric data. All</span>
    <span class="comment">//	coordinates are right-handed by definition. Valid values are &#34;X&#34;, &#34;Y&#34; (the default), or &#34;Z&#34;.</span>
    UpAxis string

    <span class="comment">//	The unit of distance that applies to all spatial measurements within the scope of this resource.</span>
    Unit struct {
        <span class="comment">//	How many real-world meters in one distance unit as a floating-point number.</span>
        <span class="comment">//	1.0 for meter, 0.01 for centimeter, 1000 for kilometer etc.</span>
        Meter float64

        <span class="comment">//	Name of the distance unit, such as &#34;centimeter&#34;, &#34;kilometer&#34;, &#34;meter&#34;, &#34;inch&#34;.</span>
        <span class="comment">//	Default is &#34;meter&#34;.</span>
        Name string
    }
    <span class="comment">//	Contributor information.</span>
    Contributors []*AssetContributor

    <span class="comment">//	Provides information about the location of the visual scene in physical space.</span>
    Coverage *AssetGeographicLocation
}</pre>
			<p>
Resource-specific asset-management information and meta-data.
</p>


			

			

			

			
				
				<h3 id="NewAsset">func <a href="/target/common.go?s=3355:3382#L112">NewAsset</a></h3>
				<pre>func NewAsset() (me *Asset)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="AssetContributor">type <a href="/target/common.go?s=3508:3694#L119">AssetContributor</a></h2>
			<pre>type AssetContributor struct {
    Author        string
    AuthorEmail   string
    AuthorWebsite string
    AuthoringTool string
    Comments      string
    Copyright     string
    SourceData    string
}</pre>
			<p>
Defines authoring information for asset management.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AssetGeographicLocation">type <a href="/target/common.go?s=3778:3918#L130">AssetGeographicLocation</a></h2>
			<pre>type AssetGeographicLocation struct {
    Longitude        float64
    Latitude         float64
    Altitude         float64
    AltitudeAbsolute bool
}</pre>
			<p>
Provides information about the location of the visual scene in physical space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1619:1746#L43">BaseDef</a></h2>
			<pre>type BaseDef struct {
    <span class="comment">//	Syncability</span>
    BaseSync

    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Extras</span>
    HasExtras
}</pre>
			<p>
Provides a common base for resource definitions.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1803:1994#L61">BaseInst</a></h2>
			<pre>type BaseInst struct {
    <span class="comment">//	Syncability</span>
    BaseSync

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The Id of the resource definition referenced by this instance.</span>
    DefRef RefId
}</pre>
			<p>
Provides a common base for resource instantiations.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=2046:2129#L79">BaseLib</a></h2>
			<pre>type BaseLib struct {
    <span class="comment">//	Syncability</span>
    BaseSync

    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName
}</pre>
			<p>
Provides a common base for resource libraries.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseSync">type <a href="/target/base.go?s=67:459#L1">BaseSync</a></h2>
			<pre>type BaseSync struct {
    <span class="comment">//	This callback, set by the core package (or your custom package), gets called by the</span>
    <span class="comment">//	SyncChanges() method. This is the ultimate point in the sync chain where the core package</span>
    <span class="comment">//	(or your custom package) picks up the changed contents of this resource.</span>
    <span class="comment">//	If the parent is a Lib then this gets called after all its Defs have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Allows for notifying outside packages of changes.
</p>


			

			

			

			

			
				
				<h3 id="BaseSync.SetDirty">func (*BaseSync) <a href="/target/base.go?s=706:736#L7">SetDirty</a></h3>
				<pre>func (me *BaseSync) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this Def or Inst by setting its fields directly
(instead of using the provided SetFoo() or SetFieldX() methods) for your changes
to be picked up by the core package (or your custom package).
</p>

				
				
			
				
				<h3 id="BaseSync.SetFieldB">func (*BaseSync) <a href="/target/base.go?s=831:883#L12">SetFieldB</a></h3>
				<pre>func (me *BaseSync) SetFieldB(field *bool, val bool)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="BaseSync.SetFieldF">func (*BaseSync) <a href="/target/base.go?s=1015:1073#L20">SetFieldF</a></h3>
				<pre>func (me *BaseSync) SetFieldF(field *float64, val float64)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="BaseSync.SyncChanges">func (*BaseSync) <a href="/target/base.go?s=1477:1510#L35">SyncChanges</a></h3>
				<pre>func (me *BaseSync) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this
Def, Inst or Lib resource that need to be picked up. Call this after you have made a number
of changes to this this resource. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="Bool2">type <a href="/target/types.go?s=95:113#L1">Bool2</a></h2>
			<pre>type Bool2 [2]bool</pre>
			<p>
Contains two bool values.
</p>


			

			

			

			

			
				
				<h3 id="Bool2.AccessIndex">func (*Bool2) <a href="/target/types.go?s=185:235#L2">AccessIndex</a></h3>
				<pre>func (me *Bool2) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Bool3">type <a href="/target/types.go?s=287:305#L7">Bool3</a></h2>
			<pre>type Bool3 [3]bool</pre>
			<p>
Contains three bool values.
</p>


			

			

			

			

			
				
				<h3 id="Bool3.AccessIndex">func (*Bool3) <a href="/target/types.go?s=377:427#L11">AccessIndex</a></h3>
				<pre>func (me *Bool3) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Bool4">type <a href="/target/types.go?s=478:496#L16">Bool4</a></h2>
			<pre>type Bool4 [4]bool</pre>
			<p>
Contains four bool values.
</p>


			

			

			

			

			
				
				<h3 id="Bool4.AccessIndex">func (*Bool4) <a href="/target/types.go?s=568:618#L20">AccessIndex</a></h3>
				<pre>func (me *Bool4) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=1285:1517#L48">CameraDef</a></h2>
			<pre>type CameraDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Describes the field of view and viewing frustum using canonical parameters.</span>
    Optics CameraOptics

    <span class="comment">//	Represents the image sensor of a camera.</span>
    Imager *CameraImager
}</pre>
			<p>
Declares a view of the visual scene hierarchy or scene graph.
</p>


			

			

			

			

			
				
				<h3 id="CameraDef.DefaultInst">func (*CameraDef) <a href="/target/camera.gt.go?s=2329:2382#L91">DefaultInst</a></h3>
				<pre>func (me *CameraDef) DefaultInst() (inst *CameraInst)</pre>
				<p>
Returns &#34;the default CameraInst instance&#34; referencing this CameraDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="CameraDef.Init">func (*CameraDef) <a href="/target/camera.gt.go?s=1537:1564#L60">Init</a></h3>
				<pre>func (me *CameraDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="CameraDef.NewInst">func (*CameraDef) <a href="/target/camera.gt.go?s=2674:2723#L101">NewInst</a></h3>
				<pre>func (me *CameraDef) NewInst() (inst *CameraInst)</pre>
				<p>
Creates and returns a new CameraInst instance referencing this CameraDef definition.
Any CameraInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="CameraImager">type <a href="/target/camera.gt.go?s=85:166#L1">CameraImager</a></h2>
			<pre>type CameraImager struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Techniques</span>
    HasTechniques
}</pre>
			<p>
Represents the image sensor of a camera (for example, film or CCD).
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=1605:1911#L64">CameraInst</a></h2>
			<pre>type CameraInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *CameraDef
}</pre>
			<p>
Instantiates a camera resource.
</p>


			

			

			

			

			
				
				<h3 id="CameraInst.EnsureDef">func (*CameraInst) <a href="/target/camera.gt.go?s=3082:3126#L112">EnsureDef</a></h3>
				<pre>func (me *CameraInst) EnsureDef() *CameraDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct CameraDef
according to the current me.DefRef value (by searching AllCameraDefLibs).
Then returns me.Def.
(Note, every CameraInst&#39;s Def is nil initially, unless it was created via CameraDef.NewInst().)
</p>

				
				
			
				
				<h3 id="CameraInst.Init">func (*CameraInst) <a href="/target/camera.gt.go?s=1931:1959#L75">Init</a></h3>
				<pre>func (me *CameraInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="CameraOptics">type <a href="/target/camera.gt.go?s=255:805#L3">CameraOptics</a></h2>
			<pre>type CameraOptics struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Aspect ratio of the field of view.</span>
        AspectRatio *SidFloat

        <span class="comment">//	Distance to the far clipping plane.</span>
        Zfar SidFloat

        <span class="comment">//	Distance to the near clipping plane.</span>
        Znear SidFloat

        <span class="comment">//	Orthographic projection type. To use Perspective instead, also set this to nil.</span>
        Orthographic *CameraOrthographic

        <span class="comment">//	Perspective projection type. To use Orthographic instead, also set this to nil.</span>
        Perspective *CameraPerspective
    }
}</pre>
			<p>
Represents the apparatus on a camera that projects the image onto the image sensor.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraOrthographic">type <a href="/target/camera.gt.go?s=865:1014#L30">CameraOrthographic</a></h2>
			<pre>type CameraOrthographic struct {
    <span class="comment">//	Horizontal magnification of the view.</span>
    MagX *SidFloat

    <span class="comment">//	Vertical magnification of the view.</span>
    MagY *SidFloat
}</pre>
			<p>
Describes the field of view of an orthographic camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraPerspective">type <a href="/target/camera.gt.go?s=1072:1218#L39">CameraPerspective</a></h2>
			<pre>type CameraPerspective struct {
    <span class="comment">//	Horizontal field of view in degrees.</span>
    FovX *SidFloat

    <span class="comment">//	Vertical field of view in degrees.</span>
    FovY *SidFloat
}</pre>
			<p>
Describes the field of view of a perspective camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ChildNode">type <a href="/target/node.gt.go?s=66:248#L1">ChildNode</a></h2>
			<pre>type ChildNode struct {
    <span class="comment">//	If set, Inst must be nil. An inline node definition.</span>
    Def *NodeDef

    <span class="comment">//	If set, Def must be nil. Instantiates a previously defined node.</span>
    Inst *NodeInst
}</pre>
			<p>
Used to recursively define hierarchies of nodes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerDef">type <a href="/target/controller.gt.go?s=1647:2038#L58">ControllerDef</a></h2>
			<pre>type ControllerDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	If set, Skin must be nil; declares this a mesh-morphing controller that deforms meshes and blends them.</span>
    Morph *ControllerMorph

    <span class="comment">//	If set, Morph must be nil; declares this a vertex-skinning controller that transforms vertices</span>
    <span class="comment">//	based on weighted influences to produce a smoothly changing mesh.</span>
    Skin *ControllerSkin
}</pre>
			<p>
Defines generic control information for dynamic content.
</p>


			

			

			

			

			
				
				<h3 id="ControllerDef.DefaultInst">func (*ControllerDef) <a href="/target/controller.gt.go?s=3160:3221#L109">DefaultInst</a></h3>
				<pre>func (me *ControllerDef) DefaultInst() (inst *ControllerInst)</pre>
				<p>
Returns &#34;the default ControllerInst instance&#34; referencing this ControllerDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="ControllerDef.Init">func (*ControllerDef) <a href="/target/controller.gt.go?s=2058:2089#L71">Init</a></h3>
				<pre>func (me *ControllerDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="ControllerDef.NewInst">func (*ControllerDef) <a href="/target/controller.gt.go?s=3533:3590#L119">NewInst</a></h3>
				<pre>func (me *ControllerDef) NewInst() (inst *ControllerInst)</pre>
				<p>
Creates and returns a new ControllerInst instance referencing this ControllerDef definition.
Any ControllerInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="ControllerInputs">type <a href="/target/controller.gt.go?s=119:196#L1">ControllerInputs</a></h2>
			<pre>type ControllerInputs struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Used to declare skinning joints or morph targets.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerInst">type <a href="/target/controller.gt.go?s=2134:2714#L75">ControllerInst</a></h2>
			<pre>type ControllerInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *ControllerDef

    <span class="comment">//	Binds a specific material to this controller instantiation.</span>
    BindMaterial *MaterialBinding

    <span class="comment">//	Indicates where a Skin controller is to start to search for the joint nodes it needs.</span>
    <span class="comment">//	This element is meaningless for Morph controllers.</span>
    SkinSkeletons []string
}</pre>
			<p>
Instantiates a controller resource.
</p>


			

			

			

			

			
				
				<h3 id="ControllerInst.EnsureDef">func (*ControllerInst) <a href="/target/controller.gt.go?s=3969:4021#L130">EnsureDef</a></h3>
				<pre>func (me *ControllerInst) EnsureDef() *ControllerDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct ControllerDef
according to the current me.DefRef value (by searching AllControllerDefLibs).
Then returns me.Def.
(Note, every ControllerInst&#39;s Def is nil initially, unless it was created via ControllerDef.NewInst().)
</p>

				
				
			
				
				<h3 id="ControllerInst.Init">func (*ControllerInst) <a href="/target/controller.gt.go?s=2734:2766#L93">Init</a></h3>
				<pre>func (me *ControllerInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="ControllerMorph">type <a href="/target/controller.gt.go?s=269:580#L7">ControllerMorph</a></h2>
			<pre>type ControllerMorph struct {
    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Which blending method to use: true for relative blending, false for normalized blending.</span>
    Relative bool

    <span class="comment">//	Refers to the Geometry that describes the base mesh.</span>
    Source RefId

    <span class="comment">//	Input meshes (morph targets) to be blended.</span>
    Targets ControllerInputs
}</pre>
			<p>
Describes the data required to blend between sets of static meshes.
</p>


			

			

			

			
				
				<h3 id="NewControllerMorph">func <a href="/target/controller.gt.go?s=597:644#L22">NewControllerMorph</a></h3>
				<pre>func NewControllerMorph() (me *ControllerMorph)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="ControllerSkin">type <a href="/target/controller.gt.go?s=798:1432#L29">ControllerSkin</a></h2>
			<pre>type ControllerSkin struct {
    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Provides extra information about the position and orientation of the base mesh before binding.</span>
    BindShapeMatrix unum.Mat4

    <span class="comment">//	Describes a per-vertex combination of joints and weights used in this skin.</span>
    <span class="comment">//	An index of –1 into the array of joints refers to the bind shape.</span>
    <span class="comment">//	Weights should be normalized before use.</span>
    VertexWeights IndexedInputs

    <span class="comment">//	Aggregates the per-joint information needed for this skin.</span>
    Joints ControllerInputs

    <span class="comment">//	Refers to the base mesh (a static mesh or a morphed mesh).</span>
    <span class="comment">//	This also provides the bind-shape of the skinned mesh.</span>
    Source RefId
}</pre>
			<p>
Contains vertex and primitive information sufficient to describe blend-weight skinning.
</p>


			

			

			

			
				
				<h3 id="NewControllerSkin">func <a href="/target/controller.gt.go?s=1449:1494#L50">NewControllerSkin</a></h3>
				<pre>func NewControllerSkin() (me *ControllerSkin)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="Document">type <a href="/target/doc.go?s=3717:3859#L48">Document</a></h2>
			<pre>type Document struct {
    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Describes a complete, fully self-contained scene graph.</span>
    Scene *Scene
}</pre>
			<p>
Encapsulates a complete, fully self-contained scene graph.
Note, resource definition libraries are organized in &#34;globals&#34; (exported package variables)
rather than Document struct instances.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Extra">type <a href="/target/common.go?s=4006:4206#L138">Extra</a></h2>
			<pre>type Extra struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	A hint as to the type of information that this particular Extra represents.</span>
    Type string
}</pre>
			<p>
Provides arbitrary additional information about or related to its parent resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2">type <a href="/target/types.go?s=671:693#L25">Float2</a></h2>
			<pre>type Float2 [2]float64</pre>
			<p>
Contains two float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float2.AccessIndex">func (*Float2) <a href="/target/types.go?s=765:816#L29">AccessIndex</a></h3>
				<pre>func (me *Float2) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float2x2">type <a href="/target/types.go?s=870:894#L34">Float2x2</a></h2>
			<pre>type Float2x2 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float2x2.AccessIndex">func (*Float2x2) <a href="/target/types.go?s=985:1038#L38">AccessIndex</a></h3>
				<pre>func (me *Float2x2) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional or two-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float2x3">type <a href="/target/types.go?s=1136:1160#L46">Float2x3</a></h2>
			<pre>type Float2x3 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float2x3.AccessIndex">func (*Float2x3) <a href="/target/types.go?s=1232:1285#L50">AccessIndex</a></h3>
				<pre>func (me *Float2x3) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float2x4">type <a href="/target/types.go?s=1385:1409#L58">Float2x4</a></h2>
			<pre>type Float2x4 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float2x4.AccessIndex">func (*Float2x4) <a href="/target/types.go?s=1481:1534#L62">AccessIndex</a></h3>
				<pre>func (me *Float2x4) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float3">type <a href="/target/types.go?s=1634:1656#L70">Float3</a></h2>
			<pre>type Float3 [3]float64</pre>
			<p>
Contains three float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float3.AccessIndex">func (*Float3) <a href="/target/types.go?s=1728:1779#L74">AccessIndex</a></h3>
				<pre>func (me *Float3) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float3x2">type <a href="/target/types.go?s=1832:1856#L79">Float3x2</a></h2>
			<pre>type Float3x2 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float3x2.AccessIndex">func (*Float3x2) <a href="/target/types.go?s=1928:1981#L83">AccessIndex</a></h3>
				<pre>func (me *Float3x2) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float3x3">type <a href="/target/types.go?s=2080:2104#L91">Float3x3</a></h2>
			<pre>type Float3x3 [9]float64</pre>
			<p>
Contains nine float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float3x3.AccessIndex">func (*Float3x3) <a href="/target/types.go?s=2176:2229#L95">AccessIndex</a></h3>
				<pre>func (me *Float3x3) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float3x4">type <a href="/target/types.go?s=2330:2355#L103">Float3x4</a></h2>
			<pre>type Float3x4 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float3x4.AccessIndex">func (*Float3x4) <a href="/target/types.go?s=2427:2480#L107">AccessIndex</a></h3>
				<pre>func (me *Float3x4) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float4">type <a href="/target/types.go?s=2579:2601#L115">Float4</a></h2>
			<pre>type Float4 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float4.AccessIndex">func (*Float4) <a href="/target/types.go?s=2673:2724#L119">AccessIndex</a></h3>
				<pre>func (me *Float4) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float4x2">type <a href="/target/types.go?s=2779:2803#L124">Float4x2</a></h2>
			<pre>type Float4x2 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float4x2.AccessIndex">func (*Float4x2) <a href="/target/types.go?s=2875:2928#L128">AccessIndex</a></h3>
				<pre>func (me *Float4x2) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float4x3">type <a href="/target/types.go?s=3029:3054#L136">Float4x3</a></h2>
			<pre>type Float4x3 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float4x3.AccessIndex">func (*Float4x3) <a href="/target/types.go?s=3126:3179#L140">AccessIndex</a></h3>
				<pre>func (me *Float4x3) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float4x4">type <a href="/target/types.go?s=3281:3306#L148">Float4x4</a></h2>
			<pre>type Float4x4 [16]float64</pre>
			<p>
Contains sixteen float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float4x4.AccessIndex">func (*Float4x4) <a href="/target/types.go?s=3378:3431#L152">AccessIndex</a></h3>
				<pre>func (me *Float4x4) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Float7">type <a href="/target/types.go?s=3531:3553#L160">Float7</a></h2>
			<pre>type Float7 [7]float64</pre>
			<p>
Contains seven float64 values.
</p>


			

			

			

			

			
				
				<h3 id="Float7.AccessIndex">func (*Float7) <a href="/target/types.go?s=3625:3676#L164">AccessIndex</a></h3>
				<pre>func (me *Float7) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Formula">type <a href="/target/formula.gt.go?s=77:196#L1">Formula</a></h2>
			<pre>type Formula struct {
    <span class="comment">//	If set, Inst must be nil.</span>
    Def *FormulaDef

    <span class="comment">//	If set, Def must be nil.</span>
    Inst *FormulaInst
}</pre>
			<p>
Provides either a formula definition or a formula instance.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FormulaDef">type <a href="/target/formula.gt.go?s=292:643#L4">FormulaDef</a></h2>
			<pre>type FormulaDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	A parameter that specifies the result variable of the formula.</span>
    Target ParamOrFloat

    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Any valid MathML (content) XML defining this formula.</span>
        MathML string
    }
}</pre>
			<p>
There are many ways to describe a formula.
COLLADA uses MathML as its common-technique.
</p>


			

			

			

			

			
				
				<h3 id="FormulaDef.DefaultInst">func (*FormulaDef) <a href="/target/formula.gt.go?s=1553:1608#L64">DefaultInst</a></h3>
				<pre>func (me *FormulaDef) DefaultInst() (inst *FormulaInst)</pre>
				<p>
Returns &#34;the default FormulaInst instance&#34; referencing this FormulaDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="FormulaDef.Init">func (*FormulaDef) <a href="/target/formula.gt.go?s=663:691#L28">Init</a></h3>
				<pre>func (me *FormulaDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FormulaDef.NewInst">func (*FormulaDef) <a href="/target/formula.gt.go?s=1905:1956#L74">NewInst</a></h3>
				<pre>func (me *FormulaDef) NewInst() (inst *FormulaInst)</pre>
				<p>
Creates and returns a new FormulaInst instance referencing this FormulaDef definition.
Any FormulaInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="FormulaInst">type <a href="/target/formula.gt.go?s=761:1099#L33">FormulaInst</a></h2>
			<pre>type FormulaInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FormulaDef
}</pre>
			<p>
Instantiates a formula resource.
</p>


			

			

			

			

			
				
				<h3 id="FormulaInst.EnsureDef">func (*FormulaInst) <a href="/target/formula.gt.go?s=2320:2366#L85">EnsureDef</a></h3>
				<pre>func (me *FormulaInst) EnsureDef() *FormulaDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct FormulaDef
according to the current me.DefRef value (by searching AllFormulaDefLibs).
Then returns me.Def.
(Note, every FormulaInst&#39;s Def is nil initially, unless it was created via FormulaDef.NewInst().)
</p>

				
				
			
				
				<h3 id="FormulaInst.Init">func (*FormulaInst) <a href="/target/formula.gt.go?s=1119:1148#L47">Init</a></h3>
				<pre>func (me *FormulaInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxAnnotation">type <a href="/target/fxeffect.gt.go?s=2127:2215#L57">FxAnnotation</a></h2>
			<pre>type FxAnnotation struct {
    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Annotation value.</span>
    Value interface{}
}</pre>
			<p>
Annotations communicate metadata from the Effect Runtime to the application only
and are not otherwise interpreted within the go-collada/dom package.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxBinding">type <a href="/target/fxmaterial.gt.go?s=117:270#L1">FxBinding</a></h2>
			<pre>type FxBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string

    <span class="comment">//	Refers to the value to bind to the specified semantic.</span>
    Target RefSid
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxColor">type <a href="/target/fxeffect.gt.go?s=2279:2396#L66">FxColor</a></h2>
			<pre>type FxColor struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Describes the literal color of the parent FxColorOrTexture.</span>
    ugfx.Rgba32
}</pre>
			<p>
Used to describe the literal color of an FxColorOrTexture.
</p>


			

			

			

			

			
				
				<h3 id="FxColor.AccessField">func (*FxColor) <a href="/target/fxeffect.gt.go?s=2477:2530#L76">AccessField</a></h3>
				<pre>func (me *FxColor) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;R&#34;, &#34;G&#34;, &#34;B&#34;, &#34;A&#34;.
</p>

				
				
			
				
				<h3 id="FxColor.AccessIndex">func (*FxColor) <a href="/target/fxeffect.gt.go?s=2778:2830#L92">AccessIndex</a></h3>
				<pre>func (me *FxColor) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices 0 through 3.
</p>

				
				
			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fxeffect.gt.go?s=3075:3611#L107">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    <span class="comment">//	Specifies from which channel to take transparency information.</span>
    <span class="comment">//	Must be one of the FxTextureOpaque* enumerated constants.</span>
    Opaque FxTextureOpaque

    <span class="comment">//	If set, refers to a previously-defined parameter in the current scope that provides</span>
    <span class="comment">//	four float values describing the literal color of this value.</span>
    ParamRef RefParam

    <span class="comment">//	If set, describes he literal color of this value.</span>
    Color *FxColor

    <span class="comment">//	If set, refers to a previously-defined FxSampler with a Kind of FxSamplerKind2D.</span>
    Texture *FxTexture
}</pre>
			<p>
Describes color attributes of fixed-function shaders inside FxProfileCommon effects.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate">type <a href="/target/fximage.gt.go?s=2854:3112#L89">FxCreate</a></h2>
			<pre>type FxCreate struct {
    <span class="comment">//	Specifies the length of the 2D array, 3D array or cube-map array.</span>
    ArrayLength uint64

    <span class="comment">//	Specifies an image&#39;s pixel or compression format.</span>
    <span class="comment">//	If not present, the format is assumed to be R8G8B8A8 linear.</span>
    Format *FxCreateFormat
}</pre>
			<p>
Fields shared by FxCreate2D, FxCreate3D and FxCreateCube
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2D">type <a href="/target/fximage.gt.go?s=3174:3785#L99">FxCreate2D</a></h2>
			<pre>type FxCreate2D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate

    <span class="comment">//	Either Exact or Ratio, but not both, must be present.</span>
    Size struct {
        <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
        Exact *FxCreate2DSizeExact

        <span class="comment">//	Specifies that the image size should be relative to the size of the viewport.</span>
        Ratio *FxCreate2DSizeRatio
    }
    <span class="comment">//	MIP information. Ignored if Unnormalized is true.</span>
    Mips *FxCreateMips

    <span class="comment">//	Unnormalized addressing of texels. (0-W, 0-H).</span>
    Unnormalized bool

    <span class="comment">//	Specifies which 2D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreateInitFrom
}</pre>
			<p>
Assists in the manual creation of a 2D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeExact">type <a href="/target/fximage.gt.go?s=3860:3966#L122">FxCreate2DSizeExact</a></h2>
			<pre>type FxCreate2DSizeExact struct {
    <span class="comment">//	width in pixels</span>
    Width uint64

    <span class="comment">//	height in pixels</span>
    Height uint64
}</pre>
			<p>
Specifies that the surface should be sized to these exact dimensions.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeRatio">type <a href="/target/fximage.gt.go?s=4181:4362#L132">FxCreate2DSizeRatio</a></h2>
			<pre>type FxCreate2DSizeRatio struct {
    <span class="comment">//	Relative width where 1.0 represents viewport width.</span>
    Width float64

    <span class="comment">//	Relative height where 1.0 represents viewport height.</span>
    Height float64
}</pre>
			<p>
Specifies that the image size should be relative to the size of the viewport. For example, 1,1 is the
same size as the viewport; 0.5,0.5 is 1/4 the size of the viewport and half as long in either direction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3D">type <a href="/target/fximage.gt.go?s=4424:4906#L141">FxCreate3D</a></h2>
			<pre>type FxCreate3D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate

    <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width in pixels for this 3D texture.</span>
        Width uint64

        <span class="comment">//	Height in pixels for this 3D texture.</span>
        Height uint64

        <span class="comment">//	Depth in pixels for this 3D texture.</span>
        Depth uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips

    <span class="comment">//	Specifies which 3D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreate3DInitFrom
}</pre>
			<p>
Assists in the manual creation of a 3D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3DInitFrom">type <a href="/target/fximage.gt.go?s=5006:5196#L164">FxCreate3DInitFrom</a></h2>
			<pre>type FxCreate3DInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom

    <span class="comment">//	Specifies the slice (depth level) within the MIP that is to be initialized.</span>
    Depth uint64
}</pre>
			<p>
Initializes an entire 3D texture or portions of a 3D texture from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCube">type <a href="/target/fximage.gt.go?s=5264:5729#L173">FxCreateCube</a></h2>
			<pre>type FxCreateCube struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate

    <span class="comment">//	Specifies that the cube surfaces should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width and height are identical across all faces in a cube-map.</span>
        Width uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips

    <span class="comment">//	Specifies which cube image to initialize, which MIP level to initialize,</span>
    <span class="comment">//	and which cube face within the MIP that is to be initialized.</span>
    InitFrom []*FxCreateCubeInitFrom
}</pre>
			<p>
Assists in the manual creation of a cube-map FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCubeInitFrom">type <a href="/target/fximage.gt.go?s=5825:6071#L191">FxCreateCubeInitFrom</a></h2>
			<pre>type FxCreateCubeInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom

    <span class="comment">//	Specifies the cube-map face within the MIP that is to be initialized.</span>
    <span class="comment">//	Must be one of the FxCubeFace* enumerated constants.</span>
    Face FxCubeFace
}</pre>
			<p>
Initializes an entire cube-map or portions of a cube-map from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormat">type <a href="/target/fximage.gt.go?s=6151:6610#L201">FxCreateFormat</a></h2>
			<pre>type FxCreateFormat struct {
    <span class="comment">//	Contains a string representing the profile- and platform-specific texel format</span>
    <span class="comment">//	that the author would like this surface to use. If this element is not specified,</span>
    <span class="comment">//	or if it is specified but the application cannot process the specified format,</span>
    <span class="comment">//	then the application uses the Hint.</span>
    Exact string

    <span class="comment">//	If this is not set, then use a common format R8G8B8A8 with linear color gradient, not sRGB.</span>
    Hint *FxCreateFormatHint
}</pre>
			<p>
Describes the formatting or memory layout expected of an FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormatHint">type <a href="/target/fximage.gt.go?s=6706:7449#L213">FxCreateFormatHint</a></h2>
			<pre>type FxCreateFormatHint struct {
    <span class="comment">//	Describes the per-texel layout of the format.</span>
    <span class="comment">//	Must be one of the FxFormatChannels* enumerated constants.</span>
    Channels FxFormatChannels

    <span class="comment">//	Describes the range of texel channel values. Each channel represents a range of values.</span>
    <span class="comment">//	Some example ranges are signed or unsigned integers, or are within a clamped range</span>
    <span class="comment">//	such as 0.0f to 1.0f, or are a high dynamic range via floating point.</span>
    <span class="comment">//	Must be one of the FxFormatRange* enumerated constants.</span>
    Range FxFormatRange

    <span class="comment">//	Identifies the precision of the texel channel value.</span>
    <span class="comment">//	Must be one of the FxFormatPrecision* enumerated constants.</span>
    Precision FxFormatPrecision

    <span class="comment">//	Optional custom / application-specific color-space information.</span>
    Space string
}</pre>
			<p>
Describes features and characteristics to select an appropriate format for image creation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateInitFrom">type <a href="/target/fximage.gt.go?s=7540:7768#L233">FxCreateInitFrom</a></h2>
			<pre>type FxCreateInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom

    <span class="comment">//	Specifies which array element in the image to initialize (fill).</span>
    ArrayIndex uint64

    <span class="comment">//	Specifies which MIP level in the image to initialize.</span>
    MipIndex uint64
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateMips">type <a href="/target/fximage.gt.go?s=7789:8085#L245">FxCreateMips</a></h2>
			<pre>type FxCreateMips struct {
    <span class="comment">//	Desired number of MIP levels. Special values: 1 is &#34;no MIP levels&#34;, 0 is &#34;all MIP levels&#34;.</span>
    Levels uint64

    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file.</span>
    <span class="comment">//	If true, no MIP levels are ever automatically initialized.</span>
    NoAutoGen bool
}</pre>
			<p>
MIP information
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCubeFace">type <a href="/target/fximage.gt.go?s=2367:2386#L66">FxCubeFace</a></h2>
			<pre>type FxCubeFace int</pre>
			<p>
Categorizes one of the six sub-images (faces) in a cube-map.
</p>


			
				<pre>const (
    <span class="comment">//	Cube-map face &#34;X negative&#34;</span>
    FxCubeFaceNx FxCubeFace = 0x8516

    <span class="comment">//	Cube-map face &#34;Y negative&#34;</span>
    FxCubeFaceNy FxCubeFace = 0x8518

    <span class="comment">//	Cube-map face &#34;Z negative&#34;</span>
    FxCubeFaceNz FxCubeFace = 0x851A

    <span class="comment">//	Cube-map face &#34;X positive&#34;</span>
    FxCubeFacePx FxCubeFace = 0x8515

    <span class="comment">//	Cube-map face &#34;Y positive&#34;</span>
    FxCubeFacePy FxCubeFace = 0x8517

    <span class="comment">//	Cube-map face &#34;Z positive&#34;</span>
    FxCubeFacePz FxCubeFace = 0x8519
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxEffectDef">type <a href="/target/fxeffect.gt.go?s=15321:15534#L508">FxEffectDef</a></h2>
			<pre>type FxEffectDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	NewParams</span>
    HasFxParamDefs

    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation

    <span class="comment">//	Rendering pipeline(s).</span>
    Profiles []*FxProfile
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry or screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectDef.Common">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=15597:15646#L523">Common</a></h3>
				<pre>func (me *FxEffectDef) Common() (prof *FxProfile)</pre>
				<p>
Returns the first FxProfile with a Common in me.Profiles.
</p>

				
				
			
				
				<h3 id="FxEffectDef.DefaultInst">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=16787:16844#L573">DefaultInst</a></h3>
				<pre>func (me *FxEffectDef) DefaultInst() (inst *FxEffectInst)</pre>
				<p>
Returns &#34;the default FxEffectInst instance&#34; referencing this FxEffectDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="FxEffectDef.Init">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=15768:15797#L534">Init</a></h3>
				<pre>func (me *FxEffectDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxEffectDef.NewInst">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=17146:17199#L583">NewInst</a></h3>
				<pre>func (me *FxEffectDef) NewInst() (inst *FxEffectInst)</pre>
				<p>
Creates and returns a new FxEffectInst instance referencing this FxEffectDef definition.
Any FxEffectInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInst">type <a href="/target/fxeffect.gt.go?s=15869:16326#L539">FxEffectInst</a></h2>
			<pre>type FxEffectInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxEffectDef

    <span class="comment">//	Platform-specific hints of which techniques to use in this effect.</span>
    TechniqueHints []*FxEffectInstTechniqueHint
}</pre>
			<p>
Instantiates an effect resource.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectInst.EnsureDef">func (*FxEffectInst) <a href="/target/fxeffect.gt.go?s=17568:17616#L594">EnsureDef</a></h3>
				<pre>func (me *FxEffectInst) EnsureDef() *FxEffectDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct FxEffectDef
according to the current me.DefRef value (by searching AllFxEffectDefLibs).
Then returns me.Def.
(Note, every FxEffectInst&#39;s Def is nil initially, unless it was created via FxEffectDef.NewInst().)
</p>

				
				
			
				
				<h3 id="FxEffectInst.Init">func (*FxEffectInst) <a href="/target/fxeffect.gt.go?s=16346:16376#L556">Init</a></h3>
				<pre>func (me *FxEffectInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInstTechniqueHint">type <a href="/target/fxeffect.gt.go?s=3801:4148#L130">FxEffectInstTechniqueHint</a></h2>
			<pre>type FxEffectInstTechniqueHint struct {
    <span class="comment">//	Defines a string that specifies for which platform this hint is intended. Optional.</span>
    Platform string

    <span class="comment">//	A reference to the name of the platform. Required.</span>
    Ref string

    <span class="comment">//	Specifies for which API profile this hint is intended.</span>
    <span class="comment">//	Optional. If set, must be either &#34;COMMON&#34; or &#34;GLSL&#34;.</span>
    Profile string
}</pre>
			<p>
Adds a hint for a platform of which technique to use in this effect.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxFilterKind">type <a href="/target/fxsampler.go?s=132:153#L1">FxFilterKind</a></h2>
			<pre>type FxFilterKind int</pre>
			<p>
Categorizes the kinds of filtering used in FxSamplerFiltering.
</p>


			
				<pre>const (
    <span class="comment">//	Bilinear filtering.</span>
    FxFilterKindNearest FxFilterKind = 0x2600

    <span class="comment">//	Trilinear filtering.</span>
    FxFilterKindLinear FxFilterKind = 0x2601

    <span class="comment">//	Compensates for distortion caused by the difference in angle between a polygon and the view plane.</span>
    FxFilterKindAnisotropic FxFilterKind = 21

    <span class="comment">//	No MIP-mapped minification.</span>
    FxFilterKindMipNone FxFilterKind = 22
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxFormatChannels">type <a href="/target/fximage.gt.go?s=68:93#L1">FxFormatChannels</a></h2>
			<pre>type FxFormatChannels int</pre>
			<p>
Categorizes the Channels of an FxCreateFormatHint.
</p>


			
				<pre>const (
    <span class="comment">//	Depth map, often used for displacement, parellax, relief, or shadow mapping.</span>
    FxFormatChannelsD FxFormatChannels = iota + 1

    <span class="comment">//	Luminance map, often used for light mapping.</span>
    FxFormatChannelsL

    <span class="comment">//	Luminance with alpha map, often used for light mapping.</span>
    FxFormatChannelsLa

    <span class="comment">//	RGB color map</span>
    FxFormatChannelsRgb

    <span class="comment">//	RGB color with alpha map. Often used for color plus transparency</span>
    <span class="comment">//	or other things packed into channel A, such as specular power.</span>
    FxFormatChannelsRgba

    <span class="comment">//	RGB color with shared exponent for HDR.</span>
    FxFormatChannelsRgbe
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxFormatPrecision">type <a href="/target/fximage.gt.go?s=705:731#L18">FxFormatPrecision</a></h2>
			<pre>type FxFormatPrecision int</pre>
			<p>
Categorizes the Precision of an FxCreateFormatHint.
</p>


			
				<pre>const (
    <span class="comment">//	Designer does not care as long as it provides &#34;reasonable&#34; precision and performance.</span>
    FxFormatPrecisionDefault FxFormatPrecision = iota

    <span class="comment">//	For integers, this typically represents 16 to 32 bits. For floating points, typically</span>
    <span class="comment">//	24 to 32 bits.</span>
    FxFormatPrecisionHigh

    <span class="comment">//	For integers, this typically represents 8 bits. For floating points, typically 16 bits.</span>
    FxFormatPrecisionLow

    <span class="comment">//	Typically 32 bits or 64 bits if available. 64 bits has been separated into its own category</span>
    <span class="comment">//	beyond HIGH because it typically has significant performance impact.</span>
    FxFormatPrecisionMax

    <span class="comment">//	For integers, this typically represents 8 to 24 bits.</span>
    <span class="comment">//	For floating points, typically 16 to 32 bits.</span>
    FxFormatPrecisionMid
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxFormatRange">type <a href="/target/fximage.gt.go?s=1507:1529#L41">FxFormatRange</a></h2>
			<pre>type FxFormatRange int</pre>
			<p>
Categorizes the Range of an FxCreateFormatHint.
</p>


			
				<pre>const (
    <span class="comment">//	Format should support full floating-point ranges.</span>
    <span class="comment">//	High precision is expected to be 32 bits.</span>
    <span class="comment">//	Mid precision may be 16 to 32 bits.</span>
    <span class="comment">//	Low precision is expected to be 16 bits.</span>
    FxFormatRangeFloat FxFormatRange = iota + 1

    <span class="comment">//	Format represents signed integer numbers. For example, 8 bits is -128 to 127.</span>
    FxFormatRangeSint

    <span class="comment">//	Format represents a decimal value that remains within the -1 to 1 range.</span>
    <span class="comment">//	Implementation could be integer-fixed-point or floating point.</span>
    FxFormatRangeSnorm

    <span class="comment">//	Format represent unsigned integer numbers. For example, 8 bits is 0 to 255.</span>
    FxFormatRangeUint

    <span class="comment">//	Format represents a decimal value that remains within the 0 to 1 range.</span>
    <span class="comment">//	Implementation could be integer-fixed-point or floating point.</span>
    FxFormatRangeUnorm
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxGlslTechniques">type <a href="/target/fxeffect.gt.go?s=12383:12432#L417">FxGlslTechniques</a></h2>
			<pre>type FxGlslTechniques map[string]*FxTechniqueGlsl</pre>
			<p>
A hash-table of GLSL techniques mapped to their scoped identifiers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxImageDef">type <a href="/target/fximage.gt.go?s=9397:10556#L289">FxImageDef</a></h2>
			<pre>type FxImageDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Indicates whether this image represents a render target.</span>
    Renderable struct {
        <span class="comment">//	If true, defines the image as a render target, meaning the image can be rendered to.</span>
        Is bool

        <span class="comment">//	Indicates whether, when instantiated, the render target is to be shared among all</span>
        <span class="comment">//	instances instead of being cloned.</span>
        Shared bool
    }
    <span class="comment">//	If set, initializes a custom 2D image by specifying its size, viewport ratio, MIP levels,</span>
    <span class="comment">//	normalization, pixel format, and data sources. It also supports arrays of 2D images.</span>
    Create2D *FxCreate2D

    <span class="comment">//	If set, initializes a custom 3D image (a volumetric image) by specifying its size, MIP level,</span>
    <span class="comment">//	pixel format, and data sources. It also supports arrays of 3D images.</span>
    Create3D *FxCreate3D

    <span class="comment">//	If set, initializes the six faces of a cube by specifying its size, MIP level, pixel format,</span>
    <span class="comment">//	and data sources. It also supports arrays of images on each of the cube faces.</span>
    <span class="comment">//	It also supports arrays of cube images.</span>
    CreateCube *FxCreateCube

    <span class="comment">//	If set, initializes the image from a URL (for example, a file) or binary image data.</span>
    InitFrom *FxImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
				
				<h3 id="FxImageDef.DefaultInst">func (*FxImageDef) <a href="/target/fximage.gt.go?s=11378:11433#L351">DefaultInst</a></h3>
				<pre>func (me *FxImageDef) DefaultInst() (inst *FxImageInst)</pre>
				<p>
Returns &#34;the default FxImageInst instance&#34; referencing this FxImageDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="FxImageDef.Init">func (*FxImageDef) <a href="/target/fximage.gt.go?s=10576:10604#L320">Init</a></h3>
				<pre>func (me *FxImageDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxImageDef.NewInst">func (*FxImageDef) <a href="/target/fximage.gt.go?s=11730:11781#L361">NewInst</a></h3>
				<pre>func (me *FxImageDef) NewInst() (inst *FxImageInst)</pre>
				<p>
Creates and returns a new FxImageInst instance referencing this FxImageDef definition.
Any FxImageInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="FxImageInitFrom">type <a href="/target/fximage.gt.go?s=8176:8396#L255">FxImageInitFrom</a></h2>
			<pre>type FxImageInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom

    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file.</span>
    <span class="comment">//	If true, no MIP levels are ever automatically initialized.</span>
    NoAutoMip bool
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			
				
				<h3 id="NewFxImageInitFrom">func <a href="/target/fximage.gt.go?s=8413:8473#L265">NewFxImageInitFrom</a></h3>
				<pre>func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxImageInst">type <a href="/target/fximage.gt.go?s=10645:10953#L324">FxImageInst</a></h2>
			<pre>type FxImageInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxImageDef
}</pre>
			<p>
Instantiates an image resource.
</p>


			

			

			

			

			
				
				<h3 id="FxImageInst.EnsureDef">func (*FxImageInst) <a href="/target/fximage.gt.go?s=12145:12191#L372">EnsureDef</a></h3>
				<pre>func (me *FxImageInst) EnsureDef() *FxImageDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct FxImageDef
according to the current me.DefRef value (by searching AllFxImageDefLibs).
Then returns me.Def.
(Note, every FxImageInst&#39;s Def is nil initially, unless it was created via FxImageDef.NewInst().)
</p>

				
				
			
				
				<h3 id="FxImageInst.Init">func (*FxImageInst) <a href="/target/fximage.gt.go?s=10973:11002#L335">Init</a></h3>
				<pre>func (me *FxImageInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxInitFrom">type <a href="/target/fximage.gt.go?s=8621:9324#L272">FxInitFrom</a></h2>
			<pre>type FxInitFrom struct {
    <span class="comment">//	Embedded binary image data; used if RefUrl is empty and Raw.Data is not.</span>
    Raw struct {
        <span class="comment">//	Contains the embedded binary image data as a sequence of bytes. Typically contains all</span>
        <span class="comment">//	the necessary information including header info such as width and height.</span>
        Data []byte

        <span class="comment">//	Specifies which codec decodes the image&#39;s descriptions and data.</span>
        <span class="comment">//	This is usually its typical file extension, such as &#34;BMP&#34;, &#34;JPG&#34;, &#34;DDS&#34;, &#34;TGA&#34;.</span>
        Format string
    }
    <span class="comment">//	Contains the URL of a file from which to take initialization data. Assumes the characteristics of the</span>
    <span class="comment">//	file: if it is a complex format such as DDS, this might include cube maps, volumes, MIPs, and so on.</span>
    RefUrl string
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=661:840#L15">FxMaterialDef</a></h2>
			<pre>type FxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	The parameterized effect instantiation that fully describes and defines this material.</span>
    Effect FxEffectInst
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry or screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialDef.DefaultInst">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=2023:2084#L64">DefaultInst</a></h3>
				<pre>func (me *FxMaterialDef) DefaultInst() (inst *FxMaterialInst)</pre>
				<p>
Returns &#34;the default FxMaterialInst instance&#34; referencing this FxMaterialDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="FxMaterialDef.Init">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=860:891#L24">Init</a></h3>
				<pre>func (me *FxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxMaterialDef.NewInst">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=2396:2453#L74">NewInst</a></h3>
				<pre>func (me *FxMaterialDef) NewInst() (inst *FxMaterialInst)</pre>
				<p>
Creates and returns a new FxMaterialInst instance referencing this FxMaterialDef definition.
Any FxMaterialInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="FxMaterialInst">type <a href="/target/fxmaterial.gt.go?s=934:1577#L28">FxMaterialInst</a></h2>
			<pre>type FxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxMaterialDef

    <span class="comment">//	Which symbol defined from within the geometry this material binds to.</span>
    Symbol string

    <span class="comment">//	Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding

    <span class="comment">//	Binds vertex inputs to effect parameters upon instantiation.</span>
    VertexInputBindings []*FxVertexInputBinding
}</pre>
			<p>
Instantiates a material resource.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialInst.AccessField">func (*FxMaterialInst) <a href="/target/-gen-refsids.go?s=41050:41110#L1672">AccessField</a></h3>
				<pre>func (me *FxMaterialInst) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Symbol&#34;.
</p>

				
				
			
				
				<h3 id="FxMaterialInst.EnsureDef">func (*FxMaterialInst) <a href="/target/fxmaterial.gt.go?s=2832:2884#L85">EnsureDef</a></h3>
				<pre>func (me *FxMaterialInst) EnsureDef() *FxMaterialDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct FxMaterialDef
according to the current me.DefRef value (by searching AllFxMaterialDefLibs).
Then returns me.Def.
(Note, every FxMaterialInst&#39;s Def is nil initially, unless it was created via FxMaterialDef.NewInst().)
</p>

				
				
			
				
				<h3 id="FxMaterialInst.Init">func (*FxMaterialInst) <a href="/target/fxmaterial.gt.go?s=1597:1629#L48">Init</a></h3>
				<pre>func (me *FxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxParamDef">type <a href="/target/fxeffect.gt.go?s=4247:4538#L143">FxParamDef</a></h2>
			<pre>type FxParamDef struct {
    <span class="comment">//	Sid and Value</span>
    ParamDef

    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation

    <span class="comment">//	Specifies constant, external, or uniform parameters.</span>
    Modifier string

    <span class="comment">//	Provides metadata that describes the purpose of a parameter declaration.</span>
    Semantic string
}</pre>
			<p>
Declares a new parameter for its parent FX-related resource, and assigns it an initial value.
</p>


			

			

			

			

			
				
				<h3 id="FxParamDef.AccessField">func (*FxParamDef) <a href="/target/-gen-refsids.go?s=38577:38633#L1552">AccessField</a></h3>
				<pre>func (me *FxParamDef) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Modifier&#34;, &#34;Semantic&#34;.
</p>

				
				
			
		
			
			
			<h2 id="FxParamDefs">type <a href="/target/fxeffect.gt.go?s=4619:4658#L158">FxParamDefs</a></h2>
			<pre>type FxParamDefs map[string]*FxParamDef</pre>
			<p>
A hash-table containing parameter declarations of this FX-related resource.
</p>


			

			

			

			

			
				
				<h3 id="FxParamDefs.Set">func (FxParamDefs) <a href="/target/fxeffect.gt.go?s=4812:4866#L162">Set</a></h3>
				<pre>func (me FxParamDefs) Set(sid string, val interface{})</pre>
				<p>
If me does not contain an FxParamDef with the specified Sid, adds it.
Next, sets the value of the FxParamDef with the specified Sid in me to val.
</p>

				
				
			
		
			
			
			<h2 id="FxPass">type <a href="/target/fxeffect.gt.go?s=5083:5498#L173">FxPass</a></h2>
			<pre>type FxPass struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation

    <span class="comment">//	Contains all rendering states to set up for this pass.</span>
    States map[string]*FxPassState

    <span class="comment">//	Links multiple shaders together to produce a pipeline for geometry processing.</span>
    Program *FxPassProgram

    <span class="comment">//	Contains evaluation elements for this rendering pass.</span>
    Evaluate *FxPassEvaluation
}</pre>
			<p>
Provides a static declaration of all the render states, shaders, and settings
for one rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewFxPass">func <a href="/target/fxeffect.gt.go?s=5515:5544#L194">NewFxPass</a></h3>
				<pre>func NewFxPass() (me *FxPass)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassEvaluation">type <a href="/target/fxeffect.gt.go?s=5661:6713#L200">FxPassEvaluation</a></h2>
			<pre>type FxPassEvaluation struct {
    <span class="comment">//	Instructs the FX Runtime what kind of geometry to submit.</span>
    Draw string

    <span class="comment">//	Color-information render target</span>
    Color struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearColor

        <span class="comment">//	Specifies which FxImageDef will receive the color information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Depth-information render target</span>
    Depth struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearDepth

        <span class="comment">//	Specifies which FxImageDef will receive the depth information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Stencil-information render target</span>
    Stencil struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearStencil

        <span class="comment">//	Specifies which FxImageDef will receive the stencil information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
}</pre>
			<p>
Contains evaluation elements for a rendering pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearColor">type <a href="/target/fxeffect.gt.go?s=6818:6991#L231">FxPassEvaluationClearColor</a></h2>
			<pre>type FxPassEvaluationClearColor struct {
    <span class="comment">//	Default clear-color value</span>
    ugfx.Rgba32

    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a color-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearDepth">type <a href="/target/fxeffect.gt.go?s=7096:7267#L240">FxPassEvaluationClearDepth</a></h2>
			<pre>type FxPassEvaluationClearDepth struct {
    <span class="comment">//	Default clear-depth value</span>
    F float64

    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a depth-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearStencil">type <a href="/target/fxeffect.gt.go?s=7374:7546#L249">FxPassEvaluationClearStencil</a></h2>
			<pre>type FxPassEvaluationClearStencil struct {
    <span class="comment">//	Default clear-stencil value</span>
    B byte

    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a stencil-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationTarget">type <a href="/target/fxeffect.gt.go?s=7634:8348#L258">FxPassEvaluationTarget</a></h2>
			<pre>type FxPassEvaluationTarget struct {
    <span class="comment">//	Indexes one of the Multiple Render Targets.</span>
    Index uint64

    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a layer of a 3D texture.</span>
    Slice uint64

    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a single MIP-map level.</span>
    Mip uint64

    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a unique cube face.</span>
    <span class="comment">//	Must be one of the FxCubeFace* enumerated constants.</span>
    CubeFace FxCubeFace

    <span class="comment">//	If set, Image is ignored; this render target references a sampler parameter to determine which image to use.</span>
    Sampler RefParam

    <span class="comment">//	If set (and Sampler is empty), this render target directly instantiates a renderable image.</span>
    Image *FxImageInst
}</pre>
			<p>
Specifies which FxImageDef will receive the information from the output of a pass.
</p>


			

			

			

			
				
				<h3 id="NewFxPassEvaluationTarget">func <a href="/target/fxeffect.gt.go?s=8365:8426#L280">NewFxPassEvaluationTarget</a></h3>
				<pre>func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassProgram">type <a href="/target/fxeffect.gt.go?s=8562:8931#L286">FxPassProgram</a></h2>
			<pre>type FxPassProgram struct {
    <span class="comment">//	Information for binding the shader variables to effect parameters.</span>
    BindAttributes []*FxPassProgramBindAttribute

    <span class="comment">//	Binds a uniform shader variable to a parameter or a value.</span>
    BindUniforms []*FxPassProgramBindUniform

    <span class="comment">//	Setup and compilation information for shaders such as vertex and pixel shaders.</span>
    Shaders []*FxPassProgramShader
}</pre>
			<p>
Links multiple shaders together to produce a pipeline for geometry processing.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindAttribute">type <a href="/target/fxeffect.gt.go?s=8992:9297#L298">FxPassProgramBindAttribute</a></h2>
			<pre>type FxPassProgramBindAttribute struct {
    <span class="comment">//	The identifier for a vertex attribute variable in the shader</span>
    <span class="comment">//	(a formal function parameter or in-scope global).</span>
    Symbol string

    <span class="comment">//	Contains an alternative name to the attribute variable</span>
    <span class="comment">//	for semantic binding to geometry vertex inputs.</span>
    Semantic string
}</pre>
			<p>
Binds semantics to vertex attribute inputs of a shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindUniform">type <a href="/target/fxeffect.gt.go?s=9402:9794#L309">FxPassProgramBindUniform</a></h2>
			<pre>type FxPassProgramBindUniform struct {
    <span class="comment">//	The identifier for a uniform input parameter to the shader</span>
    <span class="comment">//	(a formal function parameter or in-scope global) that will be bound to an external resource.</span>
    Symbol string

    <span class="comment">//	If set, refers to a previously defined parameter providing the uniform value to be bound.</span>
    ParamRef RefParam

    <span class="comment">//	If set, the uniform value to be bound.</span>
    Value interface{}
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShader">type <a href="/target/fxeffect.gt.go?s=9881:10210#L322">FxPassProgramShader</a></h2>
			<pre>type FxPassProgramShader struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	In which pipeline stage this programmable shader is designed to execute.</span>
    <span class="comment">//	Must be one of the FxShaderStage* enumerated constants.</span>
    Stage FxShaderStage

    <span class="comment">//	Concatenates the source code for the shader from one or more sources.</span>
    Sources []FxPassProgramShaderSources
}</pre>
			<p>
Declares and prepares a shader for execution in the rendering pipeline of a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShaderSources">type <a href="/target/fxeffect.gt.go?s=10260:10426#L335">FxPassProgramShaderSources</a></h2>
			<pre>type FxPassProgramShaderSources struct {
    <span class="comment">//	If true, S is an import reference; otherwise, S is code.</span>
    IsImportRef bool

    <span class="comment">//	The code or import reference.</span>
    S string
}</pre>
			<p>
Contains either code or an import reference.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassState">type <a href="/target/fxeffect.gt.go?s=10472:10777#L344">FxPassState</a></h2>
			<pre>type FxPassState struct {
    <span class="comment">//	If set, Value is ignored; refers to a previously defined parameter providing the value for this rendering state.</span>
    Param RefParam

    <span class="comment">//	If set (and Param is empty), the value for this rendering state.</span>
    Value string

    <span class="comment">//	State-specific optional index attribute.</span>
    Index float64
}</pre>
			<p>
Represents a rendering state for a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfile">type <a href="/target/fxeffect.gt.go?s=10842:11205#L356">FxProfile</a></h2>
			<pre>type FxProfile struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	NewParams</span>
    HasFxParamDefs

    <span class="comment">//	If set, Glsl must be nil, and this FxProfile represents a common, fixed-function shader pipeline.</span>
    Common *FxProfileCommon

    <span class="comment">//	If set, Common must be nil, and this FxProfile represents an OpenGL Shading Language pipeline.</span>
    Glsl *FxProfileGlsl
}</pre>
			<p>
An FX profile represents a shader-based rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewProfile">func <a href="/target/fxeffect.gt.go?s=11207:11240#L376">NewProfile</a></h3>
				<pre>func NewProfile() (me *FxProfile)</pre>
				
				
			

			
		
			
			
			<h2 id="FxProfileCommon">type <a href="/target/fxeffect.gt.go?s=11404:11513#L383">FxProfileCommon</a></h2>
			<pre>type FxProfileCommon struct {
    <span class="comment">//	Declares the only technique for this effect.</span>
    Technique FxTechniqueCommon
}</pre>
			<p>
This FX profile provides platform-independent declarations for the common, fixed-function shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfileGlsl">type <a href="/target/fxeffect.gt.go?s=11607:11953#L389">FxProfileGlsl</a></h2>
			<pre>type FxProfileGlsl struct {
    <span class="comment">//	The type of platform. This is a vendor-defined character string that</span>
    <span class="comment">//	indicates the platform or capability target for the technique. Defaults to &#34;PC&#34;.</span>
    Platform string

    <span class="comment">//	GLSL shader sources</span>
    CodesIncludes []FxProfileGlslCodeInclude

    <span class="comment">//	Declares the techniques for this effect.</span>
    Techniques FxGlslTechniques
}</pre>
			<p>
This FX profile provides platform-specific declarations for the OpenGL Shading Language.
</p>


			

			

			

			
				
				<h3 id="NewFxProfileGlsl">func <a href="/target/fxeffect.gt.go?s=11970:12013#L402">NewFxProfileGlsl</a></h3>
				<pre>func NewFxProfileGlsl() (me *FxProfileGlsl)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxProfileGlslCodeInclude">type <a href="/target/fxeffect.gt.go?s=12119:12310#L408">FxProfileGlslCodeInclude</a></h2>
			<pre>type FxProfileGlslCodeInclude struct {
    <span class="comment">//	Source code or include reference</span>
    SidString

    <span class="comment">//	Indicates whether SidString is an import reference (true) or source code (false).</span>
    IsInclude bool
}</pre>
			<p>
GLSL shader sources
</p>


			

			

			

			

			
				
				<h3 id="FxProfileGlslCodeInclude.AccessField">func (*FxProfileGlslCodeInclude) <a href="/target/-gen-refsids.go?s=39595:39665#L1600">AccessField</a></h3>
				<pre>func (me *FxProfileGlslCodeInclude) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;IsInclude&#34;.
</p>

				
				
			
		
			
			
			<h2 id="FxSampler">type <a href="/target/fxsampler.go?s=1670:1988#L55">FxSampler</a></h2>
			<pre>type FxSampler struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Filtering, Wrapping</span>
    FxSamplerStates

    <span class="comment">//	If set, instantiates a default image from which the sampler is to consume.</span>
    Image *FxImageInst

    <span class="comment">//	Indicates the kind of this texture sampler.</span>
    <span class="comment">//	Must be one of the FxSamplerKind* enumerated constants.</span>
    Kind FxSamplerKind
}</pre>
			<p>
Declares a texture sampler.
</p>


			

			

			

			
				
				<h3 id="NewFxSampler">func <a href="/target/fxsampler.go?s=2005:2040#L71">NewFxSampler</a></h3>
				<pre>func NewFxSampler() (me *FxSampler)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxSamplerFiltering">type <a href="/target/fxsampler.go?s=2252:2988#L79">FxSamplerFiltering</a></h2>
			<pre>type FxSamplerFiltering struct {
    <span class="comment">//	Magnification filter. Must be one of the FxFilterKind* enumerated constants.</span>
    FilterMag FxFilterKind

    <span class="comment">//	Minification filter. Must be one of the FxFilterKind* enumerated constants.</span>
    FilterMin FxFilterKind

    <span class="comment">//	Mip-mapping filter. Must be one of the FxFilterKind* enumerated constants.</span>
    FilterMip FxFilterKind

    <span class="comment">//	The number of samples that can be used durring anisotropic filtering.</span>
    MaxAnisotropy uint32

    <span class="comment">//	The maximum number of progressive levels that the sampler will evaluate.</span>
    MipMaxLevel uint8

    <span class="comment">//	The minimum progressive levels to begin to evaluate.</span>
    MipMinLevel uint8

    <span class="comment">//	Biases the gamma (level of detail parameter) used by the sampler to evaluate the MIPmap chain.</span>
    MipBias float64
}</pre>
			<p>
Controls texture minification, magnification and MIP-mapping.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerImage">type <a href="/target/fxsampler.go?s=3038:3111#L103">FxSamplerImage</a></h2>
			<pre>type FxSamplerImage struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    FxImageInst
}</pre>
			<p>
Instantiates an image targeted for samplers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerKind">type <a href="/target/fxsampler.go?s=561:583#L15">FxSamplerKind</a></h2>
			<pre>type FxSamplerKind int</pre>
			<p>
Categorizes the kind of an FxSampler.
</p>


			
				<pre>const (
    <span class="comment">//	Declares a one-dimensional texture sampler.</span>
    FxSamplerKind1D FxSamplerKind = 0x8B5D

    <span class="comment">//	Declares a two-dimensional texture sampler.</span>
    FxSamplerKind2D FxSamplerKind = 0x8B5E

    <span class="comment">//	Declares a three-dimensional texture sampler.</span>
    FxSamplerKind3D FxSamplerKind = 0x8B5F

    <span class="comment">//	Declares a texture sampler for cube maps.</span>
    FxSamplerKindCube FxSamplerKind = 0x8B60

    <span class="comment">//	Declares a texture sampler for depth maps.</span>
    FxSamplerKindDepth FxSamplerKind = 31

    <span class="comment">//	Declares a rectangular texture sampler.</span>
    FxSamplerKindRect FxSamplerKind = 32
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxSamplerStates">type <a href="/target/fxsampler.go?s=3182:3411#L109">FxSamplerStates</a></h2>
			<pre>type FxSamplerStates struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Controls texture minification, magnification and MIP-mapping.</span>
    Filtering *FxSamplerFiltering

    <span class="comment">//	Controls texture repeating and clamping.</span>
    Wrapping *ugfx.SamplerWrapping
}</pre>
			<p>
Allows users to modify an effect&#39;s sampler state from a material.
</p>


			

			

			

			
				
				<h3 id="NewFxSamplerStates">func <a href="/target/fxsampler.go?s=3428:3475#L121">NewFxSamplerStates</a></h3>
				<pre>func NewFxSamplerStates() (me *FxSamplerStates)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxShaderStage">type <a href="/target/fxeffect.gt.go?s=1370:1392#L36">FxShaderStage</a></h2>
			<pre>type FxShaderStage int</pre>
			<p>
Categorizes the kind of Stage in an FxPassProgramShader.
</p>


			
				<pre>const (
    <span class="comment">//	This programmable shader is designed to execute in the Tessellation pipeline stage.</span>
    FxShaderStageTessellation FxShaderStage = iota + 1

    <span class="comment">//	This programmable shader is designed to execute in the Vertex pipeline stage.</span>
    FxShaderStageVertex

    <span class="comment">//	This programmable shader is designed to execute in the Geometry pipeline stage.</span>
    FxShaderStageGeometry

    <span class="comment">//	This programmable shader is designed to execute in the Fragment pipeline stage.</span>
    FxShaderStageFragment

    <span class="comment">//	This programmable shader is designed to execute in the Compute pipeline stage.</span>
    FxShaderStageCompute
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxTechnique">type <a href="/target/fxeffect.gt.go?s=12573:12675#L421">FxTechnique</a></h2>
			<pre>type FxTechnique struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Extras</span>
    HasExtras
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect using one method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommon">type <a href="/target/fxeffect.gt.go?s=12825:14389#L437">FxTechniqueCommon</a></h2>
			<pre>type FxTechniqueCommon struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique

    <span class="comment">//	Must be one of the FxTechniqueKind* enumerated constants.</span>
    Kind FxTechniqueKind

    <span class="comment">//	Declares the amount of light emitted from the surface of this object.</span>
    Emission *FxColorOrTexture

    <span class="comment">//	Declares the color of a perfect mirror reflection.</span>
    Reflective *FxColorOrTexture

    <span class="comment">//	Declares the amount of perfect mirror reflection to be added to the reflected light</span>
    <span class="comment">//	as a value between 0.0 and 1.0.</span>
    Reflectivity *ParamOrSidFloat

    <span class="comment">//	Declares the color of perfectly refracted light.</span>
    Transparent *FxColorOrTexture

    <span class="comment">//	Declares the amount of perfectly refracted light added to the reflected color</span>
    <span class="comment">//	as a scalar value between 0.0 and 1.0.</span>
    Transparency *ParamOrSidFloat

    <span class="comment">//	Declares the index of refraction for perfectly refracted light as a single scalar index.</span>
    IndexOfRefraction *ParamOrSidFloat

    <span class="comment">//	Declares the amount of ambient light reflected from the surface of this object.</span>
    <span class="comment">//	Ignored if Kind is FxTechniqueKindConstant.</span>
    Ambient *FxColorOrTexture

    <span class="comment">//	Declares the amount of light diffusely reflected from the surface of this object.</span>
    <span class="comment">//	Ignored if Kind is FxTechniqueKindConstant.</span>
    Diffuse *FxColorOrTexture

    <span class="comment">//	Declares the color of light specularly reflected from the surface of this object.</span>
    <span class="comment">//	Ignored if Kind is FxTechniqueKindConstant or FxTechniqueKindLambert.</span>
    Specular *FxColorOrTexture

    <span class="comment">//	Declares the specularity or roughness of the specular reflection lobe.</span>
    <span class="comment">//	Ignored if Kind is FxTechniqueKindConstant or FxTechniqueKindLambert.</span>
    Shininess *ParamOrSidFloat
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect within an FxProfileCommon.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueGlsl">type <a href="/target/fxeffect.gt.go?s=14537:14794#L483">FxTechniqueGlsl</a></h2>
			<pre>type FxTechniqueGlsl struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique

    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation

    <span class="comment">//	Static declarations of all the render states, shaders, and settings for the rendering pipeline.</span>
    Passes []*FxPass
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect within an FxProfileGlsl.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueKind">type <a href="/target/fxeffect.gt.go?s=115:139#L1">FxTechniqueKind</a></h2>
			<pre>type FxTechniqueKind int</pre>
			<p>
Categorizes the Kind of an FxTechniqueCommon.
</p>


			
				<pre>const (
    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    FxTechniqueKindConstant FxTechniqueKind = iota

    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    FxTechniqueKindLambert

    <span class="comment">//	Produces a shaded surface with a Blinn BRDF approximation.</span>
    FxTechniqueKindBlinn

    <span class="comment">//	Produces a shaded surface with a Phong BRDF approximation.</span>
    FxTechniqueKindPhong
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxTexture">type <a href="/target/fxeffect.gt.go?s=14898:15212#L495">FxTexture</a></h2>
			<pre>type FxTexture struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	References a previously defined FxSampler of Kind FxSamplerKind2D.</span>
    Sampler2D RefParam

    <span class="comment">//	A semantic token, which will be referenced within FxMaterialBinding</span>
    <span class="comment">//	to bind an array of texture-coordinates from a geometry instance to the sampler.</span>
    TexCoord string
}</pre>
			<p>
Used in FxColorOrTexture instances that refer to a texture image instead of a literal color value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTextureOpaque">type <a href="/target/fxeffect.gt.go?s=604:628#L15">FxTextureOpaque</a></h2>
			<pre>type FxTextureOpaque int</pre>
			<p>
Categorizes transparency access in an FxColorOrTexture.
</p>


			
				<pre>const (
    <span class="comment">//	Takes the transparency information from the color&#39;s alpha channel,</span>
    <span class="comment">//	where the value 1.0 is opaque. This is the default.</span>
    FxTextureOpaqueA1 FxTextureOpaque = iota

    <span class="comment">//	Takes the transparency information from the color&#39;s alpha channel,</span>
    <span class="comment">//	where the value 0.0 is opaque.</span>
    FxTextureOpaqueA0

    <span class="comment">//	Takes the transparency information from the color&#39;s red, green, and blue channels,</span>
    <span class="comment">//	where the value 0.0 is opaque, with each channel modulated independently.</span>
    FxTextureOpaqueRgb0

    <span class="comment">//	Takes the transparency information from the color&#39;s red, green, and blue channels,</span>
    <span class="comment">//	where the value 1.0 is opaque, with each channel modulated independently.</span>
    FxTextureOpaqueRgb1
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="FxVertexInputBinding">type <a href="/target/fxmaterial.gt.go?s=348:552#L3">FxVertexInputBinding</a></h2>
			<pre>type FxVertexInputBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string

    <span class="comment">//	Which input semantic to bind.</span>
    InputSemantic string

    <span class="comment">//	Which input set to bind. Optional.</span>
    InputSet *uint64
}</pre>
			<p>
Binds geometry vertex inputs to effect vertex inputs upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrep">type <a href="/target/geometrybrep.go?s=124:1108#L1">GeometryBrep</a></h2>
			<pre>type GeometryBrep struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Describes all vertices of the B-rep.</span>
    <span class="comment">//	Vertices are the base topological entity for all B-rep structures.</span>
    Vertices GeometryVertices

    <span class="comment">//	Contains all curves used in this B-rep. Required if Edges are present.</span>
    Curves *GeometryBrepCurves

    <span class="comment">//	Contains all 2D curves used in this B-rep.</span>
    <span class="comment">//	This includes surfaces that describe the kind of the face. Required if Faces are present.</span>
    SurfaceCurves *GeometryBrepSurfaceCurves

    <span class="comment">//	Contains all surfaces used in this B-rep.</span>
    Surfaces *GeometryBrepSurfaces

    <span class="comment">//	Describes all edges of the B-rep.</span>
    Edges *GeometryBrepEdges

    <span class="comment">//	Describes all wires of the B-rep.</span>
    Wires *GeometryBrepWires

    <span class="comment">//	Describes all faces of the B-rep.</span>
    Faces *GeometryBrepFaces

    <span class="comment">//	Describes all pcurves of the B-rep.</span>
    Pcurves *GeometryBrepPcurves

    <span class="comment">//	Describes all shells of the B-rep.</span>
    Shells *GeometryBrepShells

    <span class="comment">//	Describes all solids of the B-rep.</span>
    Solids *GeometryBrepSolids
}</pre>
			<p>
Describes a boundary representation (B-rep) structure.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrep">func <a href="/target/geometrybrep.go?s=1125:1166#L39">NewGeometryBrep</a></h3>
				<pre>func NewGeometryBrep() (me *GeometryBrep)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepBox">type <a href="/target/geometrybrep.go?s=1300:1471#L46">GeometryBrepBox</a></h2>
			<pre>type GeometryBrepBox struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Represents the extents of the box. The dimensions of the box are double the half-extents.</span>
    HalfExtents unum.Vec3
}</pre>
			<p>
Declares an axis-aligned box that is centered around its local origin.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCapsule">type <a href="/target/geometrybrep.go?s=1519:1775#L55">GeometryBrepCapsule</a></h2>
			<pre>type GeometryBrepCapsule struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The length of the line segment connecting the centers of the capping hemispheres (ellipsoids).</span>
    Height float64

    <span class="comment">//	The x, y, and z radii of the capsule (it may be elliptical).</span>
    Radii unum.Vec3
}</pre>
			<p>
A capsule is a cylinder with rounded caps.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCircle">type <a href="/target/geometrybrep.go?s=1812:1915#L67">GeometryBrepCircle</a></h2>
			<pre>type GeometryBrepCircle struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The radius of the circle.</span>
    Radius float64
}</pre>
			<p>
Describes a circle in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCone">type <a href="/target/geometrybrep.go?s=1998:2145#L76">GeometryBrepCone</a></h2>
			<pre>type GeometryBrepCone struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The conical surface semi-angle.</span>
    Angle float64

    <span class="comment">//	Radius of the cone.</span>
    Radius float64
}</pre>
			<p>
Describes a conical surface. A cone is defined by the half-angle at its apex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurve">type <a href="/target/geometrybrep.go?s=2178:2887#L88">GeometryBrepCurve</a></h2>
			<pre>type GeometryBrepCurve struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Optional positioning of this surface to its correct location.</span>
    Location GeometryPositioning

    <span class="comment">//	The curve element. At least and at most one of these fields must be set (non-nil).</span>
    Element struct {
        <span class="comment">//	If set, curve element is a line.</span>
        Line *GeometryBrepLine

        <span class="comment">//	If set, curve element is a circle.</span>
        Circle *GeometryBrepCircle

        <span class="comment">//	If set, curve element is an ellipse.</span>
        Ellipse *GeometryBrepEllipse

        <span class="comment">//	If set, curve element is a parabola.</span>
        Parabola *GeometryBrepParabola

        <span class="comment">//	If set, curve element is a hyperbola.</span>
        Hyperbola *GeometryBrepHyperbola

        <span class="comment">//	If set, curve element is a NURBS curve.</span>
        Nurbs *GeometryBrepNurbs
    }
}</pre>
			<p>
Describes a specific curve.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurves">type <a href="/target/geometrybrep.go?s=2957:3123#L121">GeometryBrepCurves</a></h2>
			<pre>type GeometryBrepCurves struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	A container for all 3D curves used by the edges of the parent B-rep structure.</span>
    All []*GeometryBrepCurve
}</pre>
			<p>
Contains all curves that are used in the parent B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCylinder">type <a href="/target/geometrybrep.go?s=3258:3433#L131">GeometryBrepCylinder</a></h2>
			<pre>type GeometryBrepCylinder struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The first value is the major radius, the second is the minor radius (cylinder may be elliptical).</span>
    Radii Float2
}</pre>
			<p>
Describes an unlimited cylindrical surface.
An unlimited cylinder has a radius but is assumed to extend to an infinite length.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEdges">type <a href="/target/geometrybrep.go?s=3480:3907#L140">GeometryBrepEdges</a></h2>
			<pre>type GeometryBrepEdges struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Four inputs are needed to define an edge:</span>
    <span class="comment">//	One with Semantic &#34;CURVE&#34; to reference the corresponding geometric element for the edge.</span>
    <span class="comment">//	Two with Semantic &#34;VERTEX&#34; to reference the two vertices that limit each edge.</span>
    <span class="comment">//	One with Semantic &#34;PARAM&#34; to set the parametric values (start and end parameters) of the curve.</span>
    IndexedInputs
}</pre>
			<p>
Describes the edges of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEllipse">type <a href="/target/geometrybrep.go?s=3946:4091#L158">GeometryBrepEllipse</a></h2>
			<pre>type GeometryBrepEllipse struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes an ellipse in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepFaces">type <a href="/target/geometrybrep.go?s=4138:4547#L167">GeometryBrepFaces</a></h2>
			<pre>type GeometryBrepFaces struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	There must be at least three inputs:</span>
    <span class="comment">//	One with Semantic &#34;SURFACE&#34; to reference the corresponding geometric element for the face.</span>
    <span class="comment">//	One with Semantic &#34;WIRE&#34; to reference the wires for each face.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced wire within the face.</span>
    IndexedInputs
}</pre>
			<p>
Describes the faces of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepHyperbola">type <a href="/target/geometrybrep.go?s=4587:4734#L185">GeometryBrepHyperbola</a></h2>
			<pre>type GeometryBrepHyperbola struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes a hyperbola in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepLine">type <a href="/target/geometrybrep.go?s=4776:4947#L194">GeometryBrepLine</a></h2>
			<pre>type GeometryBrepLine struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The origin of the line.</span>
    Origin unum.Vec3

    <span class="comment">//	The direction of the line as a unit vector.</span>
    Direction unum.Vec3
}</pre>
			<p>
Describes a single line in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepNurbs">type <a href="/target/geometrybrep.go?s=4989:5282#L206">GeometryBrepNurbs</a></h2>
			<pre>type GeometryBrepNurbs struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Specifies the degree of the NURBS curve.</span>
    Degree uint64

    <span class="comment">//	Specifies whether this NURBS curve is closed.</span>
    Closed bool

    <span class="comment">//	Control vertices for curve interpolation.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a NURBS curve in 3D space.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrepNurbs">func <a href="/target/geometrybrep.go?s=5299:5350#L224">NewGeometryBrepNurbs</a></h3>
				<pre>func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepNurbsSurface">type <a href="/target/geometrybrep.go?s=5457:5861#L231">GeometryBrepNurbsSurface</a></h2>
			<pre>type GeometryBrepNurbsSurface struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	The u and v directions for the NURBS curve.</span>
    U, V struct {
        <span class="comment">//	Specifies the degree of the NURBS curve for this direction.</span>
        Degree uint64

        <span class="comment">//	Specifies whether a NURBS curve is closed for this direction.</span>
        Closed bool
    }
    <span class="comment">//	Control vertices for curve interpolation.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a NURBS surface in 3D space.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrepNurbsSurface">func <a href="/target/geometrybrep.go?s=5878:5943#L251">NewGeometryBrepNurbsSurface</a></h3>
				<pre>func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepOrientation">type <a href="/target/geometrybrep.go?s=6064:6198#L258">GeometryBrepOrientation</a></h2>
			<pre>type GeometryBrepOrientation struct {
    <span class="comment">//	The axis of rotation.</span>
    Axis unum.Vec3

    <span class="comment">//	The rotational angle in degrees.</span>
    Angle float64
}</pre>
			<p>
Describes the orientation of an object frame.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepParabola">type <a href="/target/geometrybrep.go?s=6237:6377#L267">GeometryBrepParabola</a></h2>
			<pre>type GeometryBrepParabola struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The distance between the parabola&#39;s focus and its apex.</span>
    FocalLength float64
}</pre>
			<p>
Describes a parabola in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPcurves">type <a href="/target/geometrybrep.go?s=6449:6770#L276">GeometryBrepPcurves</a></h2>
			<pre>type GeometryBrepPcurves struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	There must be at least three inputs:</span>
    <span class="comment">//	One with Semantic &#34;CURVE2D&#34; referencing a pcurve.</span>
    <span class="comment">//	One with Semantic &#34;FACE&#34; and one with Semantic &#34;EDGE&#34;</span>
    <span class="comment">//	to specify the connection between the edge and the face.</span>
    IndexedInputs
}</pre>
			<p>
Specifies how an edge is represented in a face&#39;s parametric space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPlane">type <a href="/target/geometrybrep.go?s=6802:6948#L294">GeometryBrepPlane</a></h2>
			<pre>type GeometryBrepPlane struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The four coefficients for the plane&#39;s equation: Ax + By + Cz + D = 0</span>
    Equation Float4
}</pre>
			<p>
Defines an infinite plane.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepShells">type <a href="/target/geometrybrep.go?s=7076:7391#L304">GeometryBrepShells</a></h2>
			<pre>type GeometryBrepShells struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	There must be at least two inputs:</span>
    <span class="comment">//	One with Semantic &#34;FACE&#34; to reference the faces for each shell.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced face within the shell.</span>
    IndexedInputs
}</pre>
			<p>
Describes the shells of a B-rep structure.
A shell is the union of one or more faces. A closed shell can limit a solid.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSolids">type <a href="/target/geometrybrep.go?s=7439:7757#L321">GeometryBrepSolids</a></h2>
			<pre>type GeometryBrepSolids struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	There must be at least two inputs:</span>
    <span class="comment">//	One with Semantic &#34;SHELL&#34; to reference the shells for each solid.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced shell within the solid.</span>
    IndexedInputs
}</pre>
			<p>
Describes the solids of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSphere">type <a href="/target/geometrybrep.go?s=7839:7943#L338">GeometryBrepSphere</a></h2>
			<pre>type GeometryBrepSphere struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The radius of this sphere.</span>
    Radius float64
}</pre>
			<p>
Describes a perfectly round sphere that is centered around its local origin.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurface">type <a href="/target/geometrybrep.go?s=7978:8784#L347">GeometryBrepSurface</a></h2>
			<pre>type GeometryBrepSurface struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Optional positioning of this surface to its correct location.</span>
    Location GeometryPositioning

    <span class="comment">//	The surface element. At least and at most one of these fields must be set (non-nil).</span>
    Element struct {
        <span class="comment">//	Surface is described by a cone.</span>
        Cone *GeometryBrepCone

        <span class="comment">//	Surface is described by a plane.</span>
        Plane *GeometryBrepPlane

        <span class="comment">//	Surface is described by a cylinder.</span>
        Cylinder *GeometryBrepCylinder

        <span class="comment">//	Surface is described by a NURBS surface.</span>
        NurbsSurface *GeometryBrepNurbsSurface

        <span class="comment">//	Surface is described by a sphere.</span>
        Sphere *GeometryBrepSphere

        <span class="comment">//	Surface is described by a torus.</span>
        Torus *GeometryBrepTorus

        <span class="comment">//	Surface is described by an extruded or revolved curve.</span>
        SweptSurface *GeometryBrepSweptSurface
    }
}</pre>
			<p>
Describes a specific surface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaceCurves">type <a href="/target/geometrybrep.go?s=8866:9037#L383">GeometryBrepSurfaceCurves</a></h2>
			<pre>type GeometryBrepSurfaceCurves struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Pcurves are curves in the parametric space of the surface on which they lie.</span>
    All []*GeometryBrepCurve
}</pre>
			<p>
Contains all parametric curves (pcurves) that are used in a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaces">type <a href="/target/geometrybrep.go?s=9100:9269#L392">GeometryBrepSurfaces</a></h2>
			<pre>type GeometryBrepSurfaces struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	A container for all surfaces used by the faces of the parent B-rep structure.</span>
    All []*GeometryBrepSurface
}</pre>
			<p>
Contains all surfaces that are used in a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSweptSurface">type <a href="/target/geometrybrep.go?s=9329:9888#L401">GeometryBrepSweptSurface</a></h2>
			<pre>type GeometryBrepSweptSurface struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Describes the base curve being extruded or revolved.</span>
    Curve *GeometryBrepCurve

    <span class="comment">//	If Direction is set (non-nil), Revolution is ignored and this surface extrudes Curve.</span>
    Extrusion struct {
        <span class="comment">//	The direction of this curve extrusion.</span>
        Direction *unum.Vec3
    }
    <span class="comment">//	Only used if Extrusion.Direction is nil; then this surface revolves Curve.</span>
    Revolution struct {
        <span class="comment">//	The origin of the axis for revolution.</span>
        Origin *unum.Vec3

        <span class="comment">//	The axis&#39; direction for revolution.</span>
        Direction *unum.Vec3
    }
}</pre>
			<p>
Describes a surface by extruding or revolving a curve.
</p>


			

			

			

			

			
				
				<h3 id="GeometryBrepSweptSurface.IsExtrusion">func (*GeometryBrepSweptSurface) <a href="/target/geometrybrep.go?s=9957:10011#L424">IsExtrusion</a></h3>
				<pre>func (me *GeometryBrepSweptSurface) IsExtrusion() bool</pre>
				<p>
Returns true if this surface is described by extruding a curve.
</p>

				
				
			
				
				<h3 id="GeometryBrepSweptSurface.IsRevolution">func (*GeometryBrepSweptSurface) <a href="/target/geometrybrep.go?s=10122:10177#L429">IsRevolution</a></h3>
				<pre>func (me *GeometryBrepSweptSurface) IsRevolution() bool</pre>
				<p>
Returns true if this surface is described by revolving a curve.
</p>

				
				
			
		
			
			
			<h2 id="GeometryBrepTorus">type <a href="/target/geometrybrep.go?s=10243:10386#L434">GeometryBrepTorus</a></h2>
			<pre>type GeometryBrepTorus struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes a torus in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepWires">type <a href="/target/geometrybrep.go?s=10433:10741#L443">GeometryBrepWires</a></h2>
			<pre>type GeometryBrepWires struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	There must be at least inputs:</span>
    <span class="comment">//	One with Semantic &#34;EDGE&#34; to reference the edges for each wire.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced edge within the wire.</span>
    IndexedInputs
}</pre>
			<p>
Describes the wires of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryControlVertices">type <a href="/target/geometry.gt.go?s=985:1069#L20">GeometryControlVertices</a></h2>
			<pre>type GeometryControlVertices struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Describes the control vertices of a spline.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryDef">type <a href="/target/geometry.gt.go?s=3683:4113#L127">GeometryDef</a></h2>
			<pre>type GeometryDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	If set, Mesh and Spline must be nil, and the GeometryDef is described by this B-rep structure.</span>
    Brep *GeometryBrep

    <span class="comment">//	If set, Brep and Spline must be nil, and the GeometryDef is described by this mesh structure.</span>
    Mesh *GeometryMesh

    <span class="comment">//	If set, Mesh and Brep must be nil, and the GeometryDef is described by this multi-segment spline.</span>
    Spline *GeometrySpline
}</pre>
			<p>
Describes the visual shape and appearance of an object in a scene.
</p>


			

			

			

			

			
				
				<h3 id="GeometryDef.DefaultInst">func (*GeometryDef) <a href="/target/geometry.gt.go?s=5147:5204#L177">DefaultInst</a></h3>
				<pre>func (me *GeometryDef) DefaultInst() (inst *GeometryInst)</pre>
				<p>
Returns &#34;the default GeometryInst instance&#34; referencing this GeometryDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="GeometryDef.Init">func (*GeometryDef) <a href="/target/geometry.gt.go?s=4133:4162#L142">Init</a></h3>
				<pre>func (me *GeometryDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="GeometryDef.NewInst">func (*GeometryDef) <a href="/target/geometry.gt.go?s=5506:5559#L187">NewInst</a></h3>
				<pre>func (me *GeometryDef) NewInst() (inst *GeometryInst)</pre>
				<p>
Creates and returns a new GeometryInst instance referencing this GeometryDef definition.
Any GeometryInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="GeometryInst">type <a href="/target/geometry.gt.go?s=4205:4715#L146">GeometryInst</a></h2>
			<pre>type GeometryInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *GeometryDef

    <span class="comment">//	Binds material symbols to material instances. This allows a single geometry</span>
    <span class="comment">//	to be instantiated into a scene multiple times each with a different appearance.</span>
    MaterialBinding *MaterialBinding
}</pre>
			<p>
Instantiates a geometry resource.
</p>


			

			

			

			

			
				
				<h3 id="GeometryInst.EnsureDef">func (*GeometryInst) <a href="/target/geometry.gt.go?s=5928:5976#L198">EnsureDef</a></h3>
				<pre>func (me *GeometryInst) EnsureDef() *GeometryDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct GeometryDef
according to the current me.DefRef value (by searching AllGeometryDefLibs).
Then returns me.Def.
(Note, every GeometryInst&#39;s Def is nil initially, unless it was created via GeometryDef.NewInst().)
</p>

				
				
			
				
				<h3 id="GeometryInst.Init">func (*GeometryInst) <a href="/target/geometry.gt.go?s=4735:4765#L161">Init</a></h3>
				<pre>func (me *GeometryInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="GeometryMesh">type <a href="/target/geometry.gt.go?s=1147:1645#L29">GeometryMesh</a></h2>
			<pre>type GeometryMesh struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Refers to a GeometryDef described by a GeometryMesh.</span>
    <span class="comment">//	If specified, compute the convex hull of the specified mesh.</span>
    ConvexHullOf RefId

    <span class="comment">//	Describes the mesh-vertex attributes and establishes their topological identity.</span>
    <span class="comment">//	Required if ConvexHullOf is empty.</span>
    Vertices *GeometryVertices

    <span class="comment">//	Geometric primitives, which assemble values from the inputs into vertex attribute data.</span>
    Primitives []*GeometryPrimitives
}</pre>
			<p>
Describes basic geometric meshes using vertex and primitive information.
</p>


			

			

			

			
				
				<h3 id="NewGeometryMesh">func <a href="/target/geometry.gt.go?s=1662:1703#L49">NewGeometryMesh</a></h3>
				<pre>func NewGeometryMesh() (me *GeometryMesh)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryPolygonHole">type <a href="/target/geometry.gt.go?s=2536:2754#L78">GeometryPolygonHole</a></h2>
			<pre>type GeometryPolygonHole struct {
    <span class="comment">//	Specifies the vertex attributes (indices) for an individual polygon.</span>
    Indices []uint64

    <span class="comment">//	Specifies the indices of a hole in the polygon specified by Indices.</span>
    Holes [][]uint64
}</pre>
			<p>
Describes a polygon that contains one or more holes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryPositioning">type <a href="/target/geometrybrep.go?s=10807:11021#L460">GeometryPositioning</a></h2>
			<pre>type GeometryPositioning struct {
    <span class="comment">//	If set, describes the origin of the object frame.</span>
    Origin *unum.Vec3

    <span class="comment">//	If set, these describe the orientation of the object frame.</span>
    Orientations []*GeometryBrepOrientation
}</pre>
			<p>
Used to position a surface or curve to its correct location.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryPrimitiveKind">type <a href="/target/geometry.gt.go?s=63:93#L1">GeometryPrimitiveKind</a></h2>
			<pre>type GeometryPrimitiveKind int</pre>
			<p>
Categorizes the kind of a GeometryPrimitives.
</p>


			
				<pre>const (
    <span class="comment">//	Organizes vertices into individual lines.</span>
    GeometryPrimitiveKindLines GeometryPrimitiveKind = 0x0001

    <span class="comment">//	Organizes vertices into connected line-strips.</span>
    GeometryPrimitiveKindLineStrips GeometryPrimitiveKind = 0x0003

    <span class="comment">//	Organizes vertices into individual polygons that may contain holes.</span>
    GeometryPrimitiveKindPolygons GeometryPrimitiveKind = 2

    <span class="comment">//	Organizes vertices into individual polygons that cannot contain holes.</span>
    GeometryPrimitiveKindPolylist GeometryPrimitiveKind = 7

    <span class="comment">//	Organizes vertices into individual triangles.</span>
    GeometryPrimitiveKindTriangles GeometryPrimitiveKind = 0x0004

    <span class="comment">//	Organizes vertices into fan-connected triangles.</span>
    GeometryPrimitiveKindTrifans GeometryPrimitiveKind = 0x0006

    <span class="comment">//	Organizes vertices into strip-connected triangles.</span>
    GeometryPrimitiveKindTristrips GeometryPrimitiveKind = 0x0005
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="GeometryPrimitives">type <a href="/target/geometry.gt.go?s=1850:2478#L56">GeometryPrimitives</a></h2>
			<pre>type GeometryPrimitives struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	When at least one input is present, one input must specify its Semantic as &#34;VERTEX&#34;.</span>
    IndexedInputs

    <span class="comment">//	Must be one of the GeometryPrimitiveKind* enumerated constants.</span>
    Kind GeometryPrimitiveKind

    <span class="comment">//	Declares a symbol for a material. This symbol is bound to a material at the time of instantiation.</span>
    <span class="comment">//	Optional. If not specified then the lighting and shading results are application defined.</span>
    Material string

    <span class="comment">//	If Kind is GeometryPrimitiveKindPolygons, describes the polygons that contain one or more holes.</span>
    PolyHoles []*GeometryPolygonHole
}</pre>
			<p>
Geometric primitives, which assemble values from inputs into vertex attribute data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometrySpline">type <a href="/target/geometry.gt.go?s=2836:3160#L87">GeometrySpline</a></h2>
			<pre>type GeometrySpline struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Sources</span>
    HasSources

    <span class="comment">//	Whether there is a segment connecting the first and last control vertices.</span>
    <span class="comment">//	The default is false, indicating that the spline is open.</span>
    Closed bool

    <span class="comment">//	Describes the control vertices of the spline.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a multisegment spline with control vertex and segment information.
</p>


			

			

			

			
				
				<h3 id="NewGeometrySpline">func <a href="/target/geometry.gt.go?s=3177:3222#L103">NewGeometrySpline</a></h3>
				<pre>func NewGeometrySpline() (me *GeometrySpline)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryVertices">type <a href="/target/geometry.gt.go?s=3500:3611#L112">GeometryVertices</a></h2>
			<pre>type GeometryVertices struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Declares the attributes and identity of mesh-vertices.
The mesh-vertices represent the position (identity) of the vertices comprising the mesh
and other vertex attributes that are invariant to tessellation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasAsset">type <a href="/target/common.go?s=82:186#L1">HasAsset</a></h2>
			<pre>type HasAsset struct {
    <span class="comment">//	Resource-specific asset-management information and meta-data.</span>
    Asset *Asset
}</pre>
			<p>
Used in all resources that require asset-management information.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasExtras">type <a href="/target/common.go?s=264:354#L1">HasExtras</a></h2>
			<pre>type HasExtras struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    Extras []*Extra
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasFxParamDefs">type <a href="/target/common.go?s=419:545#L6">HasFxParamDefs</a></h2>
			<pre>type HasFxParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams FxParamDefs
}</pre>
			<p>
Used in all FX resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasId">type <a href="/target/common.go?s=653:729#L16">HasId</a></h2>
			<pre>type HasId struct {
    <span class="comment">//	The unique identifier of this resource.</span>
    Id string
}</pre>
			<p>
Used in all resources that declare their own unique identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasInputs">type <a href="/target/common.go?s=860:992#L26">HasInputs</a></h2>
			<pre>type HasInputs struct {
    <span class="comment">//	Declares the input semantics of a data Source and connects a consumer to that Source.</span>
    Inputs []*Input
}</pre>
			<p>
Used in all data consumers that require input connections into a data Source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasName">type <a href="/target/common.go?s=1069:1164#L32">HasName</a></h2>
			<pre>type HasName struct {
    <span class="comment">//	The optional pretty-print name/title of this resource.</span>
    Name string
}</pre>
			<p>
Used in all resources that support arbitrary pretty-print names/titles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamDefs">type <a href="/target/common.go?s=1226:1348#L38">HasParamDefs</a></h2>
			<pre>type HasParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams ParamDefs
}</pre>
			<p>
Used in all resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamInsts">type <a href="/target/common.go?s=1415:1542#L44">HasParamInsts</a></h2>
			<pre>type HasParamInsts struct {
    <span class="comment">//	A hash-table containing all parameter values assigned by this resource.</span>
    SetParams ParamInsts
}</pre>
			<p>
Used in all resources that assign values to other parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSid">type <a href="/target/common.go?s=1611:1689#L50">HasSid</a></h2>
			<pre>type HasSid struct {
    <span class="comment">//	The Scoped identifier of this resource.</span>
    Sid string
}</pre>
			<p>
Used in all resources that declare their own scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSources">type <a href="/target/common.go?s=1742:1832#L56">HasSources</a></h2>
			<pre>type HasSources struct {
    <span class="comment">//	Provides the bulk of this resource&#39;s data.</span>
    Sources Sources
}</pre>
			<p>
Used in all resources that provide data arrays.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasTechniques">type <a href="/target/common.go?s=1910:2018#L62">HasTechniques</a></h2>
			<pre>type HasTechniques struct {
    <span class="comment">//	Custom-technique/foreign-profile content or data.</span>
    Techniques []*Technique
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="IndexedInputs">type <a href="/target/common.go?s=4268:4632#L156">IndexedInputs</a></h2>
			<pre>type IndexedInputs struct {
    <span class="comment">//	Number of primitives</span>
    Count uint64

    <span class="comment">//	Inputs specify how to read data from Sources.</span>
    Inputs []*InputShared

    <span class="comment">//	Indices that describe the attributes for a number of primitives.</span>
    <span class="comment">//	The indices reference into the Sources that are referenced by the Inputs.</span>
    Indices []uint64

    <span class="comment">//	Number of sub-primitives, if used.</span>
    Vcount []int64
}</pre>
			<p>
Used in various geometry primitives and b-rep resources.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Input">type <a href="/target/common.go?s=4728:4876#L172">Input</a></h2>
			<pre>type Input struct {
    <span class="comment">//	The user-defined meaning of the input connection.</span>
    Semantic string

    <span class="comment">//	Refers to the Source for this Input.</span>
    Source RefId
}</pre>
			<p>
Declares unshared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="InputShared">type <a href="/target/common.go?s=4970:5209#L181">InputShared</a></h2>
			<pre>type InputShared struct {
    <span class="comment">//	Semantic and Source</span>
    Input

    <span class="comment">//	The offset into the list of indices.</span>
    Offset uint64

    <span class="comment">//	Which inputs to group as a single set.</span>
    <span class="comment">//	This is helpful when multiple inputs share the same semantics.</span>
    Set *uint64
}</pre>
			<p>
Declares shared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int2">type <a href="/target/types.go?s=3727:3745#L169">Int2</a></h2>
			<pre>type Int2 [2]int64</pre>
			<p>
Contains two int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int2.AccessIndex">func (*Int2) <a href="/target/types.go?s=3817:3866#L173">AccessIndex</a></h3>
				<pre>func (me *Int2) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Int2x2">type <a href="/target/types.go?s=3918:3938#L178">Int2x2</a></h2>
			<pre>type Int2x2 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int2x2.AccessIndex">func (*Int2x2) <a href="/target/types.go?s=4010:4061#L182">AccessIndex</a></h3>
				<pre>func (me *Int2x2) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Int3">type <a href="/target/types.go?s=4159:4177#L190">Int3</a></h2>
			<pre>type Int3 [3]int64</pre>
			<p>
Contains three int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int3.AccessIndex">func (*Int3) <a href="/target/types.go?s=4249:4298#L194">AccessIndex</a></h3>
				<pre>func (me *Int3) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Int3x3">type <a href="/target/types.go?s=4350:4370#L199">Int3x3</a></h2>
			<pre>type Int3x3 [9]int64</pre>
			<p>
Contains nine int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int3x3.AccessIndex">func (*Int3x3) <a href="/target/types.go?s=4442:4493#L203">AccessIndex</a></h3>
				<pre>func (me *Int3x3) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Int4">type <a href="/target/types.go?s=4590:4608#L211">Int4</a></h2>
			<pre>type Int4 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int4.AccessIndex">func (*Int4) <a href="/target/types.go?s=4680:4729#L215">AccessIndex</a></h3>
				<pre>func (me *Int4) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="Int4x4">type <a href="/target/types.go?s=4784:4805#L220">Int4x4</a></h2>
			<pre>type Int4x4 [16]int64</pre>
			<p>
Contains sixteen int64 values.
</p>


			

			

			

			

			
				
				<h3 id="Int4x4.AccessIndex">func (*Int4x4) <a href="/target/types.go?s=4877:4928#L224">AccessIndex</a></h3>
				<pre>func (me *Int4x4) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="KxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=6022:6337#L231">KxArticulatedSystemDef</a></h2>
			<pre>type KxArticulatedSystemDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	If set, Motion must be nil, and this articulated system describes a kinematics system.</span>
    Kinematics *KxKinematicsSystem

    <span class="comment">//	If set, Kinematics must be nil, and this articulated system describes a motion system.</span>
    Motion *KxMotionSystem
}</pre>
			<p>
Categorizes the declaration of generic control information for kinematics systems.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemDef.DefaultInst">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=7491:7570#L285">DefaultInst</a></h3>
				<pre>func (me *KxArticulatedSystemDef) DefaultInst() (inst *KxArticulatedSystemInst)</pre>
				<p>
Returns &#34;the default KxArticulatedSystemInst instance&#34; referencing this KxArticulatedSystemDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="KxArticulatedSystemDef.Init">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=6357:6397#L243">Init</a></h3>
				<pre>func (me *KxArticulatedSystemDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxArticulatedSystemDef.NewInst">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=7927:8002#L295">NewInst</a></h3>
				<pre>func (me *KxArticulatedSystemDef) NewInst() (inst *KxArticulatedSystemInst)</pre>
				<p>
Creates and returns a new KxArticulatedSystemInst instance referencing this KxArticulatedSystemDef definition.
Any KxArticulatedSystemInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="KxArticulatedSystemInst">type <a href="/target/kxarticulatedsystem.gt.go?s=6461:6925#L247">KxArticulatedSystemInst</a></h2>
			<pre>type KxArticulatedSystemInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxArticulatedSystemDef

    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics articulated system resource.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemInst.EnsureDef">func (*KxArticulatedSystemInst) <a href="/target/kxarticulatedsystem.gt.go?s=8426:8496#L306">EnsureDef</a></h3>
				<pre>func (me *KxArticulatedSystemInst) EnsureDef() *KxArticulatedSystemDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct KxArticulatedSystemDef
according to the current me.DefRef value (by searching AllKxArticulatedSystemDefLibs).
Then returns me.Def.
(Note, every KxArticulatedSystemInst&#39;s Def is nil initially, unless it was created via KxArticulatedSystemDef.NewInst().)
</p>

				
				
			
				
				<h3 id="KxArticulatedSystemInst.Init">func (*KxArticulatedSystemInst) <a href="/target/kxarticulatedsystem.gt.go?s=6945:6986#L267">Init</a></h3>
				<pre>func (me *KxArticulatedSystemInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxAttachment">type <a href="/target/kxmodel.gt.go?s=439:870#L8">KxAttachment</a></h2>
			<pre>type KxAttachment struct {
    <span class="comment">//	Must be one of the KxAttachmentKind* enumerated constants.</span>
    Kind KxAttachmentKind

    <span class="comment">//	Refers to the KxJoint that connects the parent with the child link. Required.</span>
    Joint RefSid

    <span class="comment">//	Zero or more TransformKindRotate and/or TransformKindTranslate transformations.</span>
    Transforms []*Transform

    <span class="comment">//	If Kind is KxAttachmentKindFull, specifies the child link in this parent-child dependency.</span>
    Link *KxLink
}</pre>
			<p>
Connects links or define ends of closed loops.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxAttachmentKind">type <a href="/target/kxmodel.gt.go?s=57:82#L1">KxAttachmentKind</a></h2>
			<pre>type KxAttachmentKind int</pre>
			<p>
Categorizes the kind of a KxAttachment.
</p>


			
				<pre>const (
    <span class="comment">//	Connects two links, describing a real parent-child dependency between them.</span>
    KxAttachmentKindFull KxAttachmentKind = iota + 1

    <span class="comment">//	Connects two links and defines one end of a closed loop.</span>
    KxAttachmentKindStart

    <span class="comment">//	Defines one end of the closed loop in an attachment.</span>
    KxAttachmentKindEnd
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="KxAxisIndex">type <a href="/target/kxarticulatedsystem.gt.go?s=67:244#L1">KxAxisIndex</a></h2>
			<pre>type KxAxisIndex struct {
    <span class="comment">//	If set, specifies the special use of this index.</span>
    Semantic string

    <span class="comment">//	If not set, the parent axis will not appear in the jointmap.</span>
    I ParamOrInt
}</pre>
			<p>
Specifies the parent axis&#39; index in the jointmap.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxAxisLimits">type <a href="/target/kxarticulatedsystem.gt.go?s=289:460#L3">KxAxisLimits</a></h2>
			<pre>type KxAxisLimits struct {
    <span class="comment">//	The &#34;minimum&#34; portion of this limits descriptor.</span>
    Min ParamOrFloat

    <span class="comment">//	The &#34;maximum&#34; portion of this limits descriptor.</span>
    Max ParamOrFloat
}</pre>
			<p>
Specifies the parent axis&#39; soft limits.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxBinding">type <a href="/target/kxarticulatedsystem.gt.go?s=523:741#L12">KxBinding</a></h2>
			<pre>type KxBinding struct {
    <span class="comment">//	The identifier of the parameter to bind to the new symbol name. Required.</span>
    Symbol string

    <span class="comment">//	If set, Value is ignored.</span>
    Param RefParam

    <span class="comment">//	Only used if Param is empty.</span>
    Value interface{}
}</pre>
			<p>
Binds inputs to kinematics parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxEffector">type <a href="/target/kxarticulatedsystem.gt.go?s=805:1604#L24">KxEffector</a></h2>
			<pre>type KxEffector struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding

    <span class="comment">//	Specifies maximum speed.</span>
    <span class="comment">//	The first value is translational (m/sec), the second is rotational (°/sec).</span>
    Speed *ParamOrFloat2

    <span class="comment">//	Specifies maximum acceleration.</span>
    <span class="comment">//	The first value is translational (m/sec²), the second is rotational (°/sec²).</span>
    Acceleration *ParamOrFloat2

    <span class="comment">//	Specifies the maximum deceleration.</span>
    <span class="comment">//	The first value is translational (m/sec²), the second is rotational (°/sec²).</span>
    Deceleration *ParamOrFloat2

    <span class="comment">//	Specifies the maximum jerk (also called jolt or surge).</span>
    <span class="comment">//	The first value is translational (m/sec³), the second is rotational (°/sec³).</span>
    Jerk *ParamOrFloat2
}</pre>
			<p>
Specifies additional dynamics information for an effector.
</p>


			

			

			

			
				
				<h3 id="NewKxEffector">func <a href="/target/kxarticulatedsystem.gt.go?s=1621:1658#L58">NewKxEffector</a></h3>
				<pre>func NewKxEffector() (me *KxEffector)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxFrame">type <a href="/target/kxarticulatedsystem.gt.go?s=1818:2031#L66">KxFrame</a></h2>
			<pre>type KxFrame struct {
    <span class="comment">//	References a KxLink defined in the kinematics model. Optional.</span>
    Link RefSid

    <span class="comment">//	Zero or more TransformKindTranslate and/or TransformKindRotate transformations.</span>
    Transforms []*Transform
}</pre>
			<p>
Contains information for a frame used for kinematics calculation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxFrameObject">type <a href="/target/kxarticulatedsystem.gt.go?s=2155:2214#L76">KxFrameObject</a></h2>
			<pre>type KxFrameObject struct {
    <span class="comment">//	Link, Transforms</span>
    KxFrame
}</pre>
			<p>
Defines the offset frame from the KxFrameOrigin;
this offset usually represents the transformation to a work piece.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxFrameOrigin">type <a href="/target/kxarticulatedsystem.gt.go?s=2270:2329#L82">KxFrameOrigin</a></h2>
			<pre>type KxFrameOrigin struct {
    <span class="comment">//	Link, Transforms</span>
    KxFrame
}</pre>
			<p>
Defines the base frame for kinematics calculation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxFrameTcp">type <a href="/target/kxarticulatedsystem.gt.go?s=2473:2529#L89">KxFrameTcp</a></h2>
			<pre>type KxFrameTcp struct {
    <span class="comment">//	Link, Transforms</span>
    KxFrame
}</pre>
			<p>
Defines the offset frame from the KxFrameTip,
which usually represents the work point of the end effector (for example, a welding gun).
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxFrameTip">type <a href="/target/kxarticulatedsystem.gt.go?s=2588:2644#L95">KxFrameTip</a></h2>
			<pre>type KxFrameTip struct {
    <span class="comment">//	Link, Transforms</span>
    KxFrame
}</pre>
			<p>
Defines the frame at the end of the kinematics chain.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJoint">type <a href="/target/kxjoint.gt.go?s=502:808#L7">KxJoint</a></h2>
			<pre>type KxJoint struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Must be one of the KxJointKind* enumerated constants.</span>
    Kind KxJointKind

    <span class="comment">//	Specifies the axis of the degree of freedom.</span>
    Axis struct {
        <span class="comment">//	Name</span>
        HasName

        <span class="comment">//	Sid, V</span>
        SidVec3
    }
    <span class="comment">//	If set, these specified limits are physical limits.</span>
    Limits *KxJointLimits
}</pre>
			<p>
Primitive (simple) joints are joints with one degree of freedom (one given axis) and
are used to construct more complex joint types (compound joints) that consist of
multiple primitives, each representing an axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointAxisBinding">type <a href="/target/kxscene.gt.go?s=881:1153#L14">KxJointAxisBinding</a></h2>
			<pre>type KxJointAxisBinding struct {
    <span class="comment">//	A reference to a transformation of a node.</span>
    Target RefSid

    <span class="comment">//	If set, Value is ignored. Specifies an axis of a kinematics model.</span>
    Axis ParamOrRefSid

    <span class="comment">//	Only used if Axis is empty. Specifies a value of the axis.</span>
    Value ParamOrFloat
}</pre>
			<p>
Binds a joint axis of a kinematics model to a single transformation of a node. By binding a joint axis
to a transformation of a node, it is possible to synchronize a kinematics scene with a visual scene.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointDef">type <a href="/target/kxjoint.gt.go?s=1261:1584#L37">KxJointDef</a></h2>
			<pre>type KxJointDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Primitive (simple) joints are joints with one degree of freedom (one given axis) and are</span>
    <span class="comment">//	used to construct more complex joint types (compound joints) that</span>
    <span class="comment">//	consist of multiple primitives, each representing an axis.</span>
    All []*KxJoint
}</pre>
			<p>
Defines a single complex/compound joint with one or more degrees of freedom.
</p>


			

			

			

			

			
				
				<h3 id="KxJointDef.DefaultInst">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=2416:2471#L82">DefaultInst</a></h3>
				<pre>func (me *KxJointDef) DefaultInst() (inst *KxJointInst)</pre>
				<p>
Returns &#34;the default KxJointInst instance&#34; referencing this KxJointDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="KxJointDef.Init">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=1604:1632#L51">Init</a></h3>
				<pre>func (me *KxJointDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxJointDef.NewInst">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=2768:2819#L92">NewInst</a></h3>
				<pre>func (me *KxJointDef) NewInst() (inst *KxJointInst)</pre>
				<p>
Creates and returns a new KxJointInst instance referencing this KxJointDef definition.
Any KxJointInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="KxJointInst">type <a href="/target/kxjoint.gt.go?s=1683:1991#L55">KxJointInst</a></h2>
			<pre>type KxJointInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxJointDef
}</pre>
			<p>
Instantiates a kinematics joint resource.
</p>


			

			

			

			

			
				
				<h3 id="KxJointInst.EnsureDef">func (*KxJointInst) <a href="/target/kxjoint.gt.go?s=3183:3229#L103">EnsureDef</a></h3>
				<pre>func (me *KxJointInst) EnsureDef() *KxJointDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct KxJointDef
according to the current me.DefRef value (by searching AllKxJointDefLibs).
Then returns me.Def.
(Note, every KxJointInst&#39;s Def is nil initially, unless it was created via KxJointDef.NewInst().)
</p>

				
				
			
				
				<h3 id="KxJointInst.Init">func (*KxJointInst) <a href="/target/kxjoint.gt.go?s=2011:2040#L66">Init</a></h3>
				<pre>func (me *KxJointInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxJointKind">type <a href="/target/kxjoint.gt.go?s=52:72#L1">KxJointKind</a></h2>
			<pre>type KxJointKind int</pre>
			<p>
Categorizes the kind of a KxJoint.
</p>


			
				<pre>const (
    <span class="comment">//	Defines a single translational degree of freedom of a joint.</span>
    KxJointKindPrismatic KxJointKind = iota + 1

    <span class="comment">//	Defines a single rotational degree of freedom of a joint.</span>
    KxJointKindRevolute
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="KxJointLimits">type <a href="/target/kxjoint.gt.go?s=999:1179#L28">KxJointLimits</a></h2>
			<pre>type KxJointLimits struct {
    <span class="comment">//	If set, the &#34;minimum&#34; portion of this joint limitation.</span>
    Min *SidFloat

    <span class="comment">//	If set, the &#34;maximum&#34; portion of this joint limitation.</span>
    Max *SidFloat
}</pre>
			<p>
Declares a primitive/simple joint as fully limited (if Min and Max are both set),
partially limited (if either Min or Max is nil, but not both) or unlimited (if Min and Max are nil).
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxKinematicsAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=2736:3440#L101">KxKinematicsAxis</a></h2>
			<pre>type KxKinematicsAxis struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	The joint axis of an instantiated kinematics model.</span>
    Axis RefSid

    <span class="comment">//	Defaults to true.</span>
    Active ParamOrBool

    <span class="comment">//	Specifies this axis&#39; indices in the jointmap. If empty, this axis will not appear in the jointmap.</span>
    Indices []*KxAxisIndex

    <span class="comment">//	Specifies the soft limits. If not set, the axis is limited only by its physical limits.</span>
    Limits *KxAxisLimits

    <span class="comment">//	Defaults to false.</span>
    Locked ParamOrBool

    <span class="comment">//	Formulas can be useful to define the behavior of a passive link according to one or more</span>
    <span class="comment">//	active axes, or to define dependencies of the soft limits and another joint, for example.</span>
    Formulas []Formula
}</pre>
			<p>
Contains axis information to describe the kinematics behavior of an articulated model.
</p>


			

			

			

			
				
				<h3 id="NewKxKinematicsAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=3457:3506#L132">NewKxKinematicsAxis</a></h3>
				<pre>func NewKxKinematicsAxis() (me *KxKinematicsAxis)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxKinematicsSystem">type <a href="/target/kxarticulatedsystem.gt.go?s=3690:4535#L139">KxKinematicsSystem</a></h2>
			<pre>type KxKinematicsSystem struct {
    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	The kinematics models to be enhanced with kinematics information.</span>
    Models []*KxModelInst

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Kinematics-related information for all axes.</span>
        AxisInfos []*KxKinematicsAxis

        <span class="comment">//	Kinematics calculation chain frames</span>
        Frame struct {
            <span class="comment">//	Defines the base frame for kinematics calculation.</span>
            Origin KxFrameOrigin

            <span class="comment">//	Defines the frame at the end of the kinematics chain.</span>
            Tip KxFrameTip

            <span class="comment">//	If set, defines the offset frame from the Tip frame,</span>
            <span class="comment">//	which usually represents the work point of the end effector (for example, a welding gun).</span>
            Tcp *KxFrameTcp

            <span class="comment">//	If set, defines the offset frame from the Origin frame;</span>
            <span class="comment">//	this offset usually represents the transformation to a work piece.</span>
            Object *KxFrameObject
        }
    }
}</pre>
			<p>
Contains additional information to describe the kinematical behavior of an articulated model.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxLink">type <a href="/target/kxmodel.gt.go?s=977:1218#L23">KxLink</a></h2>
			<pre>type KxLink struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Zero or more TransformKindRotate and/or TransformKindTranslate transformations.</span>
    Transforms []*Transform

    <span class="comment">//	The attachments that make up this link.</span>
    Attachments []*KxAttachment
}</pre>
			<p>
Represents a rigid kinematical object without mass whose motion is constrained by one or more joints.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelBinding">type <a href="/target/kxscene.gt.go?s=194:669#L1">KxModelBinding</a></h2>
			<pre>type KxModelBinding struct {
    <span class="comment">//	A reference to a node.</span>
    Node RefId

    <span class="comment">//	Refers to the kinematics model being bound.</span>
    <span class="comment">//	Only either SidRef or ParamRef, but not both, must be specified.</span>
    Model struct {
        <span class="comment">//	If set, ParamRef must be empty.</span>
        <span class="comment">//	The Sid path to the kinematics model to bind to the node.</span>
        SidRef RefSid

        <span class="comment">//	If set, SidRef must be empty.</span>
        <span class="comment">//	The parameter of the kinematics model that is defined in the instantiated kinematics scene.</span>
        ParamRef RefParam
    }
}</pre>
			<p>
Binds a kinematics model to a node. The description of a kinematics model is
completely independent of any visual information, but for calculation the position is important.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelDef">type <a href="/target/kxmodel.gt.go?s=1479:1763#L40">KxModelDef</a></h2>
			<pre>type KxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	NewParams</span>
        HasParamDefs

        <span class="comment">//	The kinematics chain.</span>
        Links []*KxLink

        <span class="comment">//	Specifies dependencies among the joints.</span>
        Formulas []Formula
    }
}</pre>
			<p>
Categorizes the declaration of kinematical information, containing declarations of
joints, links, and attachment points. A kinematics model is focused on strict
kinematics description &#34;in zero position&#34;, without any additional physical descriptions.
</p>


			

			

			

			

			
				
				<h3 id="KxModelDef.DefaultInst">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=2815:2870#L104">DefaultInst</a></h3>
				<pre>func (me *KxModelDef) DefaultInst() (inst *KxModelInst)</pre>
				<p>
Returns &#34;the default KxModelInst instance&#34; referencing this KxModelDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="KxModelDef.Init">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=1783:1811#L61">Init</a></h3>
				<pre>func (me *KxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxModelDef.NewInst">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=3167:3218#L114">NewInst</a></h3>
				<pre>func (me *KxModelDef) NewInst() (inst *KxModelInst)</pre>
				<p>
Creates and returns a new KxModelInst instance referencing this KxModelDef definition.
Any KxModelInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="KxModelInst">type <a href="/target/kxmodel.gt.go?s=1893:2333#L66">KxModelInst</a></h2>
			<pre>type KxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxModelDef

    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics model resource.
</p>


			

			

			

			

			
				
				<h3 id="KxModelInst.EnsureDef">func (*KxModelInst) <a href="/target/kxmodel.gt.go?s=3582:3628#L125">EnsureDef</a></h3>
				<pre>func (me *KxModelInst) EnsureDef() *KxModelDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct KxModelDef
according to the current me.DefRef value (by searching AllKxModelDefLibs).
Then returns me.Def.
(Note, every KxModelInst&#39;s Def is nil initially, unless it was created via KxModelDef.NewInst().)
</p>

				
				
			
				
				<h3 id="KxModelInst.Init">func (*KxModelInst) <a href="/target/kxmodel.gt.go?s=2353:2382#L86">Init</a></h3>
				<pre>func (me *KxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxMotionAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=4623:5327#L171">KxMotionAxis</a></h2>
			<pre>type KxMotionAxis struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	References the KxKinematicsAxis of an instantiated kinematics system.</span>
    Axis RefSid

    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding

    <span class="comment">//	The maximum permitted speed of the axis in meters per second (m/sec).</span>
    Speed *ParamOrFloat

    <span class="comment">//	The maximum permitted acceleration of the axis in m/sec².</span>
    Acceleration *ParamOrFloat

    <span class="comment">//	The maximum permitted deceleration of an axis.</span>
    <span class="comment">//	If not set, acceleration and deceleration have the same value in m/sec².</span>
    Deceleration *ParamOrFloat

    <span class="comment">//	The maximum permitted jerk of an axis in m/sec³.</span>
    Jerk *ParamOrFloat
}</pre>
			<p>
Contains axis information to describe the motion behavior of an articulated model.
</p>


			

			

			

			
				
				<h3 id="NewKxMotionAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=5344:5385#L205">NewKxMotionAxis</a></h3>
				<pre>func NewKxMotionAxis() (me *KxMotionAxis)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxMotionSystem">type <a href="/target/kxarticulatedsystem.gt.go?s=5573:5934#L213">KxMotionSystem</a></h2>
			<pre>type KxMotionSystem struct {
    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	The articulated system to be enhanced with dynamics information.</span>
    ArticulatedSystem *KxArticulatedSystemInst

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamics-related information for all axes.</span>
        AxisInfos []*KxMotionAxis

        <span class="comment">//	Additional dynamics information</span>
        EffectorInfo *KxEffector
    }
}</pre>
			<p>
Contains additional information to describe the dynamics behaviour of an articulated model.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxSceneDef">type <a href="/target/kxscene.gt.go?s=1249:1536#L26">KxSceneDef</a></h2>
			<pre>type KxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Zero or more kinematics models participating in this kinematics scene.</span>
    Models []*KxModelInst

    <span class="comment">//	Zero or more articulated systems participating in this kinematics scene.</span>
    ArticulatedSystems []*KxArticulatedSystemInst
}</pre>
			<p>
Embodies the entire set of kinematics information that can be articulated from a resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneDef.DefaultInst">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=2708:2763#L83">DefaultInst</a></h3>
				<pre>func (me *KxSceneDef) DefaultInst() (inst *KxSceneInst)</pre>
				<p>
Returns &#34;the default KxSceneInst instance&#34; referencing this KxSceneDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="KxSceneDef.Init">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=1556:1584#L38">Init</a></h3>
				<pre>func (me *KxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxSceneDef.NewInst">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=3060:3111#L93">NewInst</a></h3>
				<pre>func (me *KxSceneDef) NewInst() (inst *KxSceneInst)</pre>
				<p>
Creates and returns a new KxSceneInst instance referencing this KxSceneDef definition.
Any KxSceneInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="KxSceneInst">type <a href="/target/kxscene.gt.go?s=1635:2226#L42">KxSceneInst</a></h2>
			<pre>type KxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	NewParams</span>
    HasParamDefs

    <span class="comment">//	SetParams</span>
    HasParamInsts

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxSceneDef

    <span class="comment">//	Zero or more bindings of kinematics models to nodes.</span>
    ModelBindings []*KxModelBinding

    <span class="comment">//	Zero or more bindings of kinematics models&#39; joint axes to single node transformations.</span>
    JointAxisBindings []*KxJointAxisBinding
}</pre>
			<p>
Instantiates a kinematics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneInst.EnsureDef">func (*KxSceneInst) <a href="/target/kxscene.gt.go?s=3475:3521#L104">EnsureDef</a></h3>
				<pre>func (me *KxSceneInst) EnsureDef() *KxSceneDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct KxSceneDef
according to the current me.DefRef value (by searching AllKxSceneDefLibs).
Then returns me.Def.
(Note, every KxSceneInst&#39;s Def is nil initially, unless it was created via KxSceneDef.NewInst().)
</p>

				
				
			
				
				<h3 id="KxSceneInst.Init">func (*KxSceneInst) <a href="/target/kxscene.gt.go?s=2246:2275#L65">Init</a></h3>
				<pre>func (me *KxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Layers">type <a href="/target/common.go?s=5279:5306#L194">Layers</a></h2>
			<pre>type Layers map[string]bool</pre>
			<p>
Allows simple association of resources with custom named layers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LibAnimationClipDefs">type <a href="/target/animationclip.gt.go?s=4176:4456#L124">LibAnimationClipDefs</a></h2>
			<pre>type LibAnimationClipDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationClipDef
}</pre>
			<p>
A library that contains AnimationClipDefs associated by their Id.
To create a new LibAnimationClipDefs library, ONLY use the LibsAnimationClipDef.New() or LibsAnimationClipDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationClipDefs.Add">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4845:4923#L141">Add</a></h3>
				<pre>func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</pre>
				<p>
Adds the specified AnimationClipDef definition to this LibAnimationClipDefs, and returns it.
If this LibAnimationClipDefs already contains a AnimationClipDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.AddNew">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5257:5324#L151">AddNew</a></h3>
				<pre>func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</pre>
				<p>
Creates a new AnimationClipDef definition with the specified Id, adds it to this LibAnimationClipDefs, and returns it.
If this LibAnimationClipDefs already contains a AnimationClipDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Len">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5397:5438#L154">Len</a></h3>
				<pre>func (me *LibAnimationClipDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.New">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5597:5667#L158">New</a></h3>
				<pre>func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</pre>
				<p>
Creates a new AnimationClipDef definition with the specified Id and returns it,
but does not add it to this LibAnimationClipDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Remove">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5797:5846#L161">Remove</a></h3>
				<pre>func (me *LibAnimationClipDefs) Remove(id string)</pre>
				<p>
Removes the AnimationClipDef with the specified Id from this LibAnimationClipDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.SyncChanges">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=6204:6249#L166">SyncChanges</a></h3>
				<pre>func (me *LibAnimationClipDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibAnimationClipDefs
that need to be picked up. Call this after you have made a number of changes to this LibAnimationClipDefs
library or its AnimationClipDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibAnimationDefs">type <a href="/target/animation.gt.go?s=5540:5812#L174">LibAnimationDefs</a></h2>
			<pre>type LibAnimationDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationDef
}</pre>
			<p>
A library that contains AnimationDefs associated by their Id.
To create a new LibAnimationDefs library, ONLY use the LibsAnimationDef.New() or LibsAnimationDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationDefs.Add">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6169:6235#L191">Add</a></h3>
				<pre>func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</pre>
				<p>
Adds the specified AnimationDef definition to this LibAnimationDefs, and returns it.
If this LibAnimationDefs already contains a AnimationDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.AddNew">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6553:6612#L201">AddNew</a></h3>
				<pre>func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</pre>
				<p>
Creates a new AnimationDef definition with the specified Id, adds it to this LibAnimationDefs, and returns it.
If this LibAnimationDefs already contains a AnimationDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Len">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6685:6722#L204">Len</a></h3>
				<pre>func (me *LibAnimationDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.New">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6873:6935#L208">New</a></h3>
				<pre>func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</pre>
				<p>
Creates a new AnimationDef definition with the specified Id and returns it,
but does not add it to this LibAnimationDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Remove">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=7053:7098#L211">Remove</a></h3>
				<pre>func (me *LibAnimationDefs) Remove(id string)</pre>
				<p>
Removes the AnimationDef with the specified Id from this LibAnimationDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.SyncChanges">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=7444:7485#L216">SyncChanges</a></h3>
				<pre>func (me *LibAnimationDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibAnimationDefs
that need to be picked up. Call this after you have made a number of changes to this LibAnimationDefs
library or its AnimationDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=4764:5030#L171">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains CameraDefs associated by their Id.
To create a new LibCameraDefs library, ONLY use the LibsCameraDef.New() or LibsCameraDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5363:5420#L188">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified CameraDef definition to this LibCameraDefs, and returns it.
If this LibCameraDefs already contains a CameraDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5726:5779#L198">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new CameraDef definition with the specified Id, adds it to this LibCameraDefs, and returns it.
If this LibCameraDefs already contains a CameraDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Len">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5852:5886#L201">Len</a></h3>
				<pre>func (me *LibCameraDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=6031:6087#L205">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new CameraDef definition with the specified Id and returns it,
but does not add it to this LibCameraDefs.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=6196:6238#L208">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the CameraDef with the specified Id from this LibCameraDefs.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=6575:6613#L213">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibCameraDefs
that need to be picked up. Call this after you have made a number of changes to this LibCameraDefs
library or its CameraDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibControllerDefs">type <a href="/target/controller.gt.go?s=5799:6073#L189">LibControllerDefs</a></h2>
			<pre>type LibControllerDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*ControllerDef
}</pre>
			<p>
A library that contains ControllerDefs associated by their Id.
To create a new LibControllerDefs library, ONLY use the LibsControllerDef.New() or LibsControllerDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibControllerDefs.Add">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6438:6507#L206">Add</a></h3>
				<pre>func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</pre>
				<p>
Adds the specified ControllerDef definition to this LibControllerDefs, and returns it.
If this LibControllerDefs already contains a ControllerDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.AddNew">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6829:6890#L216">AddNew</a></h3>
				<pre>func (me *LibControllerDefs) AddNew(id string) *ControllerDef</pre>
				<p>
Creates a new ControllerDef definition with the specified Id, adds it to this LibControllerDefs, and returns it.
If this LibControllerDefs already contains a ControllerDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Len">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6963:7001#L219">Len</a></h3>
				<pre>func (me *LibControllerDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibControllerDefs.New">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=7154:7218#L223">New</a></h3>
				<pre>func (me *LibControllerDefs) New(id string) (def *ControllerDef)</pre>
				<p>
Creates a new ControllerDef definition with the specified Id and returns it,
but does not add it to this LibControllerDefs.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Remove">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=7339:7385#L226">Remove</a></h3>
				<pre>func (me *LibControllerDefs) Remove(id string)</pre>
				<p>
Removes the ControllerDef with the specified Id from this LibControllerDefs.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.SyncChanges">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=7734:7776#L231">SyncChanges</a></h3>
				<pre>func (me *LibControllerDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibControllerDefs
that need to be picked up. Call this after you have made a number of changes to this LibControllerDefs
library or its ControllerDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFormulaDefs">type <a href="/target/formula.gt.go?s=4039:4307#L144">LibFormulaDefs</a></h2>
			<pre>type LibFormulaDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FormulaDef
}</pre>
			<p>
A library that contains FormulaDefs associated by their Id.
To create a new LibFormulaDefs library, ONLY use the LibsFormulaDef.New() or LibsFormulaDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFormulaDefs.Add">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4648:4708#L161">Add</a></h3>
				<pre>func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</pre>
				<p>
Adds the specified FormulaDef definition to this LibFormulaDefs, and returns it.
If this LibFormulaDefs already contains a FormulaDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.AddNew">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5018:5073#L171">AddNew</a></h3>
				<pre>func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</pre>
				<p>
Creates a new FormulaDef definition with the specified Id, adds it to this LibFormulaDefs, and returns it.
If this LibFormulaDefs already contains a FormulaDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Len">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5146:5181#L174">Len</a></h3>
				<pre>func (me *LibFormulaDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.New">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5328:5386#L178">New</a></h3>
				<pre>func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</pre>
				<p>
Creates a new FormulaDef definition with the specified Id and returns it,
but does not add it to this LibFormulaDefs.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Remove">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5498:5541#L181">Remove</a></h3>
				<pre>func (me *LibFormulaDefs) Remove(id string)</pre>
				<p>
Removes the FormulaDef with the specified Id from this LibFormulaDefs.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.SyncChanges">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5881:5920#L186">SyncChanges</a></h3>
				<pre>func (me *LibFormulaDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFormulaDefs
that need to be picked up. Call this after you have made a number of changes to this LibFormulaDefs
library or its FormulaDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxEffectDefs">type <a href="/target/fxeffect.gt.go?s=19324:19594#L653">LibFxEffectDefs</a></h2>
			<pre>type LibFxEffectDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxEffectDef
}</pre>
			<p>
A library that contains FxEffectDefs associated by their Id.
To create a new LibFxEffectDefs library, ONLY use the LibsFxEffectDef.New() or LibsFxEffectDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffectDefs.Add">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=19943:20006#L670">Add</a></h3>
				<pre>func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</pre>
				<p>
Adds the specified FxEffectDef definition to this LibFxEffectDefs, and returns it.
If this LibFxEffectDefs already contains a FxEffectDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.AddNew">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=20320:20377#L680">AddNew</a></h3>
				<pre>func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</pre>
				<p>
Creates a new FxEffectDef definition with the specified Id, adds it to this LibFxEffectDefs, and returns it.
If this LibFxEffectDefs already contains a FxEffectDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Len">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=20450:20486#L683">Len</a></h3>
				<pre>func (me *LibFxEffectDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.New">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=20635:20695#L687">New</a></h3>
				<pre>func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</pre>
				<p>
Creates a new FxEffectDef definition with the specified Id and returns it,
but does not add it to this LibFxEffectDefs.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Remove">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=20810:20854#L690">Remove</a></h3>
				<pre>func (me *LibFxEffectDefs) Remove(id string)</pre>
				<p>
Removes the FxEffectDef with the specified Id from this LibFxEffectDefs.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.SyncChanges">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=21197:21237#L695">SyncChanges</a></h3>
				<pre>func (me *LibFxEffectDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxEffectDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxEffectDefs
library or its FxEffectDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxImageDefs">type <a href="/target/fximage.gt.go?s=13864:14132#L431">LibFxImageDefs</a></h2>
			<pre>type LibFxImageDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxImageDef
}</pre>
			<p>
A library that contains FxImageDefs associated by their Id.
To create a new LibFxImageDefs library, ONLY use the LibsFxImageDef.New() or LibsFxImageDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImageDefs.Add">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14473:14533#L448">Add</a></h3>
				<pre>func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</pre>
				<p>
Adds the specified FxImageDef definition to this LibFxImageDefs, and returns it.
If this LibFxImageDefs already contains a FxImageDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.AddNew">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14843:14898#L458">AddNew</a></h3>
				<pre>func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</pre>
				<p>
Creates a new FxImageDef definition with the specified Id, adds it to this LibFxImageDefs, and returns it.
If this LibFxImageDefs already contains a FxImageDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Len">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14971:15006#L461">Len</a></h3>
				<pre>func (me *LibFxImageDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.New">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=15153:15211#L465">New</a></h3>
				<pre>func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</pre>
				<p>
Creates a new FxImageDef definition with the specified Id and returns it,
but does not add it to this LibFxImageDefs.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Remove">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=15323:15366#L468">Remove</a></h3>
				<pre>func (me *LibFxImageDefs) Remove(id string)</pre>
				<p>
Removes the FxImageDef with the specified Id from this LibFxImageDefs.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.SyncChanges">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=15706:15745#L473">SyncChanges</a></h3>
				<pre>func (me *LibFxImageDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxImageDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxImageDefs
library or its FxImageDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxMaterialDefs">type <a href="/target/fxmaterial.gt.go?s=4662:4936#L144">LibFxMaterialDefs</a></h2>
			<pre>type LibFxMaterialDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxMaterialDef
}</pre>
			<p>
A library that contains FxMaterialDefs associated by their Id.
To create a new LibFxMaterialDefs library, ONLY use the LibsFxMaterialDef.New() or LibsFxMaterialDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterialDefs.Add">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5301:5370#L161">Add</a></h3>
				<pre>func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</pre>
				<p>
Adds the specified FxMaterialDef definition to this LibFxMaterialDefs, and returns it.
If this LibFxMaterialDefs already contains a FxMaterialDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.AddNew">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5692:5753#L171">AddNew</a></h3>
				<pre>func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</pre>
				<p>
Creates a new FxMaterialDef definition with the specified Id, adds it to this LibFxMaterialDefs, and returns it.
If this LibFxMaterialDefs already contains a FxMaterialDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Len">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5826:5864#L174">Len</a></h3>
				<pre>func (me *LibFxMaterialDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.New">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=6017:6081#L178">New</a></h3>
				<pre>func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</pre>
				<p>
Creates a new FxMaterialDef definition with the specified Id and returns it,
but does not add it to this LibFxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Remove">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=6202:6248#L181">Remove</a></h3>
				<pre>func (me *LibFxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the FxMaterialDef with the specified Id from this LibFxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.SyncChanges">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=6597:6639#L186">SyncChanges</a></h3>
				<pre>func (me *LibFxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxMaterialDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxMaterialDefs
library or its FxMaterialDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibGeometryDefs">type <a href="/target/geometry.gt.go?s=7684:7954#L257">LibGeometryDefs</a></h2>
			<pre>type LibGeometryDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*GeometryDef
}</pre>
			<p>
A library that contains GeometryDefs associated by their Id.
To create a new LibGeometryDefs library, ONLY use the LibsGeometryDef.New() or LibsGeometryDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibGeometryDefs.Add">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8303:8366#L274">Add</a></h3>
				<pre>func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</pre>
				<p>
Adds the specified GeometryDef definition to this LibGeometryDefs, and returns it.
If this LibGeometryDefs already contains a GeometryDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.AddNew">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8680:8737#L284">AddNew</a></h3>
				<pre>func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</pre>
				<p>
Creates a new GeometryDef definition with the specified Id, adds it to this LibGeometryDefs, and returns it.
If this LibGeometryDefs already contains a GeometryDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Len">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8810:8846#L287">Len</a></h3>
				<pre>func (me *LibGeometryDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.New">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8995:9055#L291">New</a></h3>
				<pre>func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</pre>
				<p>
Creates a new GeometryDef definition with the specified Id and returns it,
but does not add it to this LibGeometryDefs.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Remove">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=9170:9214#L294">Remove</a></h3>
				<pre>func (me *LibGeometryDefs) Remove(id string)</pre>
				<p>
Removes the GeometryDef with the specified Id from this LibGeometryDefs.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.SyncChanges">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=9557:9597#L299">SyncChanges</a></h3>
				<pre>func (me *LibGeometryDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibGeometryDefs
that need to be picked up. Call this after you have made a number of changes to this LibGeometryDefs
library or its GeometryDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxArticulatedSystemDefs">type <a href="/target/kxarticulatedsystem.gt.go?s=10589:10881#L365">LibKxArticulatedSystemDefs</a></h2>
			<pre>type LibKxArticulatedSystemDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxArticulatedSystemDef
}</pre>
			<p>
A library that contains KxArticulatedSystemDefs associated by their Id.
To create a new LibKxArticulatedSystemDefs library, ONLY use the LibsKxArticulatedSystemDef.New() or LibsKxArticulatedSystemDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxArticulatedSystemDefs.Add">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11318:11414#L382">Add</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</pre>
				<p>
Adds the specified KxArticulatedSystemDef definition to this LibKxArticulatedSystemDefs, and returns it.
If this LibKxArticulatedSystemDefs already contains a KxArticulatedSystemDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.AddNew">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11772:11851#L392">AddNew</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</pre>
				<p>
Creates a new KxArticulatedSystemDef definition with the specified Id, adds it to this LibKxArticulatedSystemDefs, and returns it.
If this LibKxArticulatedSystemDefs already contains a KxArticulatedSystemDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Len">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11924:11971#L395">Len</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.New">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=12142:12224#L399">New</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</pre>
				<p>
Creates a new KxArticulatedSystemDef definition with the specified Id and returns it,
but does not add it to this LibKxArticulatedSystemDefs.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Remove">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=12372:12427#L402">Remove</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Remove(id string)</pre>
				<p>
Removes the KxArticulatedSystemDef with the specified Id from this LibKxArticulatedSystemDefs.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.SyncChanges">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=12803:12854#L407">SyncChanges</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxArticulatedSystemDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxArticulatedSystemDefs
library or its KxArticulatedSystemDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxJointDefs">type <a href="/target/kxjoint.gt.go?s=4902:5170#L162">LibKxJointDefs</a></h2>
			<pre>type LibKxJointDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxJointDef
}</pre>
			<p>
A library that contains KxJointDefs associated by their Id.
To create a new LibKxJointDefs library, ONLY use the LibsKxJointDef.New() or LibsKxJointDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxJointDefs.Add">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5511:5571#L179">Add</a></h3>
				<pre>func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</pre>
				<p>
Adds the specified KxJointDef definition to this LibKxJointDefs, and returns it.
If this LibKxJointDefs already contains a KxJointDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.AddNew">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5881:5936#L189">AddNew</a></h3>
				<pre>func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</pre>
				<p>
Creates a new KxJointDef definition with the specified Id, adds it to this LibKxJointDefs, and returns it.
If this LibKxJointDefs already contains a KxJointDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Len">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=6009:6044#L192">Len</a></h3>
				<pre>func (me *LibKxJointDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.New">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=6191:6249#L196">New</a></h3>
				<pre>func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</pre>
				<p>
Creates a new KxJointDef definition with the specified Id and returns it,
but does not add it to this LibKxJointDefs.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Remove">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=6361:6404#L199">Remove</a></h3>
				<pre>func (me *LibKxJointDefs) Remove(id string)</pre>
				<p>
Removes the KxJointDef with the specified Id from this LibKxJointDefs.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.SyncChanges">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=6744:6783#L204">SyncChanges</a></h3>
				<pre>func (me *LibKxJointDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxJointDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxJointDefs
library or its KxJointDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxModelDefs">type <a href="/target/kxmodel.gt.go?s=5301:5569#L184">LibKxModelDefs</a></h2>
			<pre>type LibKxModelDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxModelDef
}</pre>
			<p>
A library that contains KxModelDefs associated by their Id.
To create a new LibKxModelDefs library, ONLY use the LibsKxModelDef.New() or LibsKxModelDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxModelDefs.Add">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5910:5970#L201">Add</a></h3>
				<pre>func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</pre>
				<p>
Adds the specified KxModelDef definition to this LibKxModelDefs, and returns it.
If this LibKxModelDefs already contains a KxModelDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.AddNew">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=6280:6335#L211">AddNew</a></h3>
				<pre>func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</pre>
				<p>
Creates a new KxModelDef definition with the specified Id, adds it to this LibKxModelDefs, and returns it.
If this LibKxModelDefs already contains a KxModelDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Len">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=6408:6443#L214">Len</a></h3>
				<pre>func (me *LibKxModelDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.New">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=6590:6648#L218">New</a></h3>
				<pre>func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</pre>
				<p>
Creates a new KxModelDef definition with the specified Id and returns it,
but does not add it to this LibKxModelDefs.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Remove">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=6760:6803#L221">Remove</a></h3>
				<pre>func (me *LibKxModelDefs) Remove(id string)</pre>
				<p>
Removes the KxModelDef with the specified Id from this LibKxModelDefs.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.SyncChanges">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=7143:7182#L226">SyncChanges</a></h3>
				<pre>func (me *LibKxModelDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxModelDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxModelDefs
library or its KxModelDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxSceneDefs">type <a href="/target/kxscene.gt.go?s=5194:5462#L163">LibKxSceneDefs</a></h2>
			<pre>type LibKxSceneDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxSceneDef
}</pre>
			<p>
A library that contains KxSceneDefs associated by their Id.
To create a new LibKxSceneDefs library, ONLY use the LibsKxSceneDef.New() or LibsKxSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxSceneDefs.Add">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5803:5863#L180">Add</a></h3>
				<pre>func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</pre>
				<p>
Adds the specified KxSceneDef definition to this LibKxSceneDefs, and returns it.
If this LibKxSceneDefs already contains a KxSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.AddNew">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=6173:6228#L190">AddNew</a></h3>
				<pre>func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</pre>
				<p>
Creates a new KxSceneDef definition with the specified Id, adds it to this LibKxSceneDefs, and returns it.
If this LibKxSceneDefs already contains a KxSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Len">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=6301:6336#L193">Len</a></h3>
				<pre>func (me *LibKxSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.New">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=6483:6541#L197">New</a></h3>
				<pre>func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</pre>
				<p>
Creates a new KxSceneDef definition with the specified Id and returns it,
but does not add it to this LibKxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Remove">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=6653:6696#L200">Remove</a></h3>
				<pre>func (me *LibKxSceneDefs) Remove(id string)</pre>
				<p>
Removes the KxSceneDef with the specified Id from this LibKxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.SyncChanges">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=7036:7075#L205">SyncChanges</a></h3>
				<pre>func (me *LibKxSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxSceneDefs
library or its KxSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibLightDefs">type <a href="/target/light.gt.go?s=6369:6633#L217">LibLightDefs</a></h2>
			<pre>type LibLightDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*LightDef
}</pre>
			<p>
A library that contains LightDefs associated by their Id.
To create a new LibLightDefs library, ONLY use the LibsLightDef.New() or LibsLightDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibLightDefs.Add">func (*LibLightDefs) <a href="/target/light.gt.go?s=6958:7012#L234">Add</a></h3>
				<pre>func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</pre>
				<p>
Adds the specified LightDef definition to this LibLightDefs, and returns it.
If this LibLightDefs already contains a LightDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibLightDefs.AddNew">func (*LibLightDefs) <a href="/target/light.gt.go?s=7314:7365#L244">AddNew</a></h3>
				<pre>func (me *LibLightDefs) AddNew(id string) *LightDef</pre>
				<p>
Creates a new LightDef definition with the specified Id, adds it to this LibLightDefs, and returns it.
If this LibLightDefs already contains a LightDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Len">func (*LibLightDefs) <a href="/target/light.gt.go?s=7438:7471#L247">Len</a></h3>
				<pre>func (me *LibLightDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibLightDefs.New">func (*LibLightDefs) <a href="/target/light.gt.go?s=7614:7668#L251">New</a></h3>
				<pre>func (me *LibLightDefs) New(id string) (def *LightDef)</pre>
				<p>
Creates a new LightDef definition with the specified Id and returns it,
but does not add it to this LibLightDefs.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Remove">func (*LibLightDefs) <a href="/target/light.gt.go?s=7774:7815#L254">Remove</a></h3>
				<pre>func (me *LibLightDefs) Remove(id string)</pre>
				<p>
Removes the LightDef with the specified Id from this LibLightDefs.
</p>

				
				
			
				
				<h3 id="LibLightDefs.SyncChanges">func (*LibLightDefs) <a href="/target/light.gt.go?s=8149:8186#L259">SyncChanges</a></h3>
				<pre>func (me *LibLightDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibLightDefs
that need to be picked up. Call this after you have made a number of changes to this LibLightDefs
library or its LightDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=4342:4604#L154">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains NodeDefs associated by their Id.
To create a new LibNodeDefs library, ONLY use the LibsNodeDef.New() or LibsNodeDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4921:4972#L171">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified NodeDef definition to this LibNodeDefs, and returns it.
If this LibNodeDefs already contains a NodeDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5270:5319#L181">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new NodeDef definition with the specified Id, adds it to this LibNodeDefs, and returns it.
If this LibNodeDefs already contains a NodeDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Len">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5392:5424#L184">Len</a></h3>
				<pre>func (me *LibNodeDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5565:5617#L188">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new NodeDef definition with the specified Id and returns it,
but does not add it to this LibNodeDefs.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5720:5760#L191">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the NodeDef with the specified Id from this LibNodeDefs.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=6091:6127#L196">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibNodeDefs
that need to be picked up. Call this after you have made a number of changes to this LibNodeDefs
library or its NodeDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxForceFieldDefs">type <a href="/target/pxforcefield.gt.go?s=3922:4200#L116">LibPxForceFieldDefs</a></h2>
			<pre>type LibPxForceFieldDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxForceFieldDef
}</pre>
			<p>
A library that contains PxForceFieldDefs associated by their Id.
To create a new LibPxForceFieldDefs library, ONLY use the LibsPxForceFieldDef.New() or LibsPxForceFieldDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxForceFieldDefs.Add">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4581:4656#L133">Add</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</pre>
				<p>
Adds the specified PxForceFieldDef definition to this LibPxForceFieldDefs, and returns it.
If this LibPxForceFieldDefs already contains a PxForceFieldDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.AddNew">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4986:5051#L143">AddNew</a></h3>
				<pre>func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</pre>
				<p>
Creates a new PxForceFieldDef definition with the specified Id, adds it to this LibPxForceFieldDefs, and returns it.
If this LibPxForceFieldDefs already contains a PxForceFieldDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Len">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=5124:5164#L146">Len</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.New">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=5321:5389#L150">New</a></h3>
				<pre>func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</pre>
				<p>
Creates a new PxForceFieldDef definition with the specified Id and returns it,
but does not add it to this LibPxForceFieldDefs.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Remove">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=5516:5564#L153">Remove</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Remove(id string)</pre>
				<p>
Removes the PxForceFieldDef with the specified Id from this LibPxForceFieldDefs.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.SyncChanges">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=5919:5963#L158">SyncChanges</a></h3>
				<pre>func (me *LibPxForceFieldDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxForceFieldDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxForceFieldDefs
library or its PxForceFieldDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxMaterialDefs">type <a href="/target/pxmaterial.gt.go?s=4060:4334#L127">LibPxMaterialDefs</a></h2>
			<pre>type LibPxMaterialDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxMaterialDef
}</pre>
			<p>
A library that contains PxMaterialDefs associated by their Id.
To create a new LibPxMaterialDefs library, ONLY use the LibsPxMaterialDef.New() or LibsPxMaterialDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxMaterialDefs.Add">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4699:4768#L144">Add</a></h3>
				<pre>func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</pre>
				<p>
Adds the specified PxMaterialDef definition to this LibPxMaterialDefs, and returns it.
If this LibPxMaterialDefs already contains a PxMaterialDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.AddNew">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5090:5151#L154">AddNew</a></h3>
				<pre>func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</pre>
				<p>
Creates a new PxMaterialDef definition with the specified Id, adds it to this LibPxMaterialDefs, and returns it.
If this LibPxMaterialDefs already contains a PxMaterialDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Len">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5224:5262#L157">Len</a></h3>
				<pre>func (me *LibPxMaterialDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.New">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5415:5479#L161">New</a></h3>
				<pre>func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</pre>
				<p>
Creates a new PxMaterialDef definition with the specified Id and returns it,
but does not add it to this LibPxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Remove">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5600:5646#L164">Remove</a></h3>
				<pre>func (me *LibPxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the PxMaterialDef with the specified Id from this LibPxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.SyncChanges">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5995:6037#L169">SyncChanges</a></h3>
				<pre>func (me *LibPxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxMaterialDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxMaterialDefs
library or its PxMaterialDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxModelDefs">type <a href="/target/pxmodel.gt.go?s=5026:5294#L142">LibPxModelDefs</a></h2>
			<pre>type LibPxModelDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxModelDef
}</pre>
			<p>
A library that contains PxModelDefs associated by their Id.
To create a new LibPxModelDefs library, ONLY use the LibsPxModelDef.New() or LibsPxModelDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxModelDefs.Add">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5635:5695#L159">Add</a></h3>
				<pre>func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</pre>
				<p>
Adds the specified PxModelDef definition to this LibPxModelDefs, and returns it.
If this LibPxModelDefs already contains a PxModelDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.AddNew">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6005:6060#L169">AddNew</a></h3>
				<pre>func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</pre>
				<p>
Creates a new PxModelDef definition with the specified Id, adds it to this LibPxModelDefs, and returns it.
If this LibPxModelDefs already contains a PxModelDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Len">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6133:6168#L172">Len</a></h3>
				<pre>func (me *LibPxModelDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.New">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6315:6373#L176">New</a></h3>
				<pre>func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</pre>
				<p>
Creates a new PxModelDef definition with the specified Id and returns it,
but does not add it to this LibPxModelDefs.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Remove">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6485:6528#L179">Remove</a></h3>
				<pre>func (me *LibPxModelDefs) Remove(id string)</pre>
				<p>
Removes the PxModelDef with the specified Id from this LibPxModelDefs.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.SyncChanges">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6868:6907#L184">SyncChanges</a></h3>
				<pre>func (me *LibPxModelDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxModelDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxModelDefs
library or its PxModelDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxSceneDefs">type <a href="/target/pxscene.gt.go?s=4202:4470#L132">LibPxSceneDefs</a></h2>
			<pre>type LibPxSceneDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxSceneDef
}</pre>
			<p>
A library that contains PxSceneDefs associated by their Id.
To create a new LibPxSceneDefs library, ONLY use the LibsPxSceneDef.New() or LibsPxSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxSceneDefs.Add">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4811:4871#L149">Add</a></h3>
				<pre>func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</pre>
				<p>
Adds the specified PxSceneDef definition to this LibPxSceneDefs, and returns it.
If this LibPxSceneDefs already contains a PxSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.AddNew">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=5181:5236#L159">AddNew</a></h3>
				<pre>func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</pre>
				<p>
Creates a new PxSceneDef definition with the specified Id, adds it to this LibPxSceneDefs, and returns it.
If this LibPxSceneDefs already contains a PxSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Len">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=5309:5344#L162">Len</a></h3>
				<pre>func (me *LibPxSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.New">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=5491:5549#L166">New</a></h3>
				<pre>func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</pre>
				<p>
Creates a new PxSceneDef definition with the specified Id and returns it,
but does not add it to this LibPxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Remove">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=5661:5704#L169">Remove</a></h3>
				<pre>func (me *LibPxSceneDefs) Remove(id string)</pre>
				<p>
Removes the PxSceneDef with the specified Id from this LibPxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.SyncChanges">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=6044:6083#L174">SyncChanges</a></h3>
				<pre>func (me *LibPxSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxSceneDefs
library or its PxSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=5531:5807#L180">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    <span class="comment">//	Id, Name</span>
    BaseLib

    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains VisualSceneDefs associated by their Id.
To create a new LibVisualSceneDefs library, ONLY use the LibsVisualSceneDef.New() or LibsVisualSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6180:6252#L197">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified VisualSceneDef definition to this LibVisualSceneDefs, and returns it.
If this LibVisualSceneDefs already contains a VisualSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6578:6641#L207">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new VisualSceneDef definition with the specified Id, adds it to this LibVisualSceneDefs, and returns it.
If this LibVisualSceneDefs already contains a VisualSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Len">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6714:6753#L210">Len</a></h3>
				<pre>func (me *LibVisualSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6908:6974#L214">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new VisualSceneDef definition with the specified Id and returns it,
but does not add it to this LibVisualSceneDefs.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=7098:7145#L217">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the VisualSceneDef with the specified Id from this LibVisualSceneDefs.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=7497:7540#L222">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibVisualSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibVisualSceneDefs
library or its VisualSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationClipDef">type <a href="/target/animationclip.gt.go?s=3384:3442#L104">LibsAnimationClipDef</a></h2>
			<pre>type LibsAnimationClipDef map[string]*LibAnimationClipDefs</pre>
			<p>
The underlying type of the global AllAnimationClipDefLibs variable:
a hash-table that contains LibAnimationClipDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationClipDef.AddNew">func (LibsAnimationClipDef) <a href="/target/animationclip.gt.go?s=3700:3776#L108">AddNew</a></h3>
				<pre>func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</pre>
				<p>
Creates a new LibAnimationClipDefs library with the specified Id, adds it to this LibsAnimationClipDef, and returns it.
If this LibsAnimationClipDef already contains a LibAnimationClipDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationDef">type <a href="/target/animation.gt.go?s=4808:4858#L154">LibsAnimationDef</a></h2>
			<pre>type LibsAnimationDef map[string]*LibAnimationDefs</pre>
			<p>
The underlying type of the global AllAnimationDefLibs variable:
a hash-table that contains LibAnimationDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationDef.AddNew">func (LibsAnimationDef) <a href="/target/animation.gt.go?s=5100:5168#L158">AddNew</a></h3>
				<pre>func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</pre>
				<p>
Creates a new LibAnimationDefs library with the specified Id, adds it to this LibsAnimationDef, and returns it.
If this LibsAnimationDef already contains a LibAnimationDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=4077:4121#L151">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global AllCameraDefLibs variable:
a hash-table that contains LibCameraDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=4351:4413#L155">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new LibCameraDefs library with the specified Id, adds it to this LibsCameraDef, and returns it.
If this LibsCameraDef already contains a LibCameraDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsControllerDef">type <a href="/target/controller.gt.go?s=5052:5104#L169">LibsControllerDef</a></h2>
			<pre>type LibsControllerDef map[string]*LibControllerDefs</pre>
			<p>
The underlying type of the global AllControllerDefLibs variable:
a hash-table that contains LibControllerDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsControllerDef.AddNew">func (LibsControllerDef) <a href="/target/controller.gt.go?s=5350:5420#L173">AddNew</a></h3>
				<pre>func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</pre>
				<p>
Creates a new LibControllerDefs library with the specified Id, adds it to this LibsControllerDef, and returns it.
If this LibsControllerDef already contains a LibControllerDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFormulaDef">type <a href="/target/formula.gt.go?s=3337:3383#L124">LibsFormulaDef</a></h2>
			<pre>type LibsFormulaDef map[string]*LibFormulaDefs</pre>
			<p>
The underlying type of the global AllFormulaDefLibs variable:
a hash-table that contains LibFormulaDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFormulaDef.AddNew">func (LibsFormulaDef) <a href="/target/formula.gt.go?s=3617:3681#L128">AddNew</a></h3>
				<pre>func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</pre>
				<p>
Creates a new LibFormulaDefs library with the specified Id, adds it to this LibsFormulaDef, and returns it.
If this LibsFormulaDef already contains a LibFormulaDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxEffectDef">type <a href="/target/fxeffect.gt.go?s=18607:18655#L633">LibsFxEffectDef</a></h2>
			<pre>type LibsFxEffectDef map[string]*LibFxEffectDefs</pre>
			<p>
The underlying type of the global AllFxEffectDefLibs variable:
a hash-table that contains LibFxEffectDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxEffectDef.AddNew">func (LibsFxEffectDef) <a href="/target/fxeffect.gt.go?s=18893:18959#L637">AddNew</a></h3>
				<pre>func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</pre>
				<p>
Creates a new LibFxEffectDefs library with the specified Id, adds it to this LibsFxEffectDef, and returns it.
If this LibsFxEffectDef already contains a LibFxEffectDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxImageDef">type <a href="/target/fximage.gt.go?s=13162:13208#L411">LibsFxImageDef</a></h2>
			<pre>type LibsFxImageDef map[string]*LibFxImageDefs</pre>
			<p>
The underlying type of the global AllFxImageDefLibs variable:
a hash-table that contains LibFxImageDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxImageDef.AddNew">func (LibsFxImageDef) <a href="/target/fximage.gt.go?s=13442:13506#L415">AddNew</a></h3>
				<pre>func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</pre>
				<p>
Creates a new LibFxImageDefs library with the specified Id, adds it to this LibsFxImageDef, and returns it.
If this LibsFxImageDef already contains a LibFxImageDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=3915:3967#L124">LibsFxMaterialDef</a></h2>
			<pre>type LibsFxMaterialDef map[string]*LibFxMaterialDefs</pre>
			<p>
The underlying type of the global AllFxMaterialDefLibs variable:
a hash-table that contains LibFxMaterialDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxMaterialDef.AddNew">func (LibsFxMaterialDef) <a href="/target/fxmaterial.gt.go?s=4213:4283#L128">AddNew</a></h3>
				<pre>func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</pre>
				<p>
Creates a new LibFxMaterialDefs library with the specified Id, adds it to this LibsFxMaterialDef, and returns it.
If this LibsFxMaterialDef already contains a LibFxMaterialDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsGeometryDef">type <a href="/target/geometry.gt.go?s=6967:7015#L237">LibsGeometryDef</a></h2>
			<pre>type LibsGeometryDef map[string]*LibGeometryDefs</pre>
			<p>
The underlying type of the global AllGeometryDefLibs variable:
a hash-table that contains LibGeometryDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsGeometryDef.AddNew">func (LibsGeometryDef) <a href="/target/geometry.gt.go?s=7253:7319#L241">AddNew</a></h3>
				<pre>func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</pre>
				<p>
Creates a new LibGeometryDefs library with the specified Id, adds it to this LibsGeometryDef, and returns it.
If this LibsGeometryDef already contains a LibGeometryDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=9707:9777#L345">LibsKxArticulatedSystemDef</a></h2>
			<pre>type LibsKxArticulatedSystemDef map[string]*LibKxArticulatedSystemDefs</pre>
			<p>
The underlying type of the global AllKxArticulatedSystemDefLibs variable:
a hash-table that contains LibKxArticulatedSystemDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxArticulatedSystemDef.AddNew">func (LibsKxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=10059:10147#L349">AddNew</a></h3>
				<pre>func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</pre>
				<p>
Creates a new LibKxArticulatedSystemDefs library with the specified Id, adds it to this LibsKxArticulatedSystemDef, and returns it.
If this LibsKxArticulatedSystemDef already contains a LibKxArticulatedSystemDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxJointDef">type <a href="/target/kxjoint.gt.go?s=4200:4246#L142">LibsKxJointDef</a></h2>
			<pre>type LibsKxJointDef map[string]*LibKxJointDefs</pre>
			<p>
The underlying type of the global AllKxJointDefLibs variable:
a hash-table that contains LibKxJointDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxJointDef.AddNew">func (LibsKxJointDef) <a href="/target/kxjoint.gt.go?s=4480:4544#L146">AddNew</a></h3>
				<pre>func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</pre>
				<p>
Creates a new LibKxJointDefs library with the specified Id, adds it to this LibsKxJointDef, and returns it.
If this LibsKxJointDef already contains a LibKxJointDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxModelDef">type <a href="/target/kxmodel.gt.go?s=4599:4645#L164">LibsKxModelDef</a></h2>
			<pre>type LibsKxModelDef map[string]*LibKxModelDefs</pre>
			<p>
The underlying type of the global AllKxModelDefLibs variable:
a hash-table that contains LibKxModelDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxModelDef.AddNew">func (LibsKxModelDef) <a href="/target/kxmodel.gt.go?s=4879:4943#L168">AddNew</a></h3>
				<pre>func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</pre>
				<p>
Creates a new LibKxModelDefs library with the specified Id, adds it to this LibsKxModelDef, and returns it.
If this LibsKxModelDef already contains a LibKxModelDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxSceneDef">type <a href="/target/kxscene.gt.go?s=4492:4538#L143">LibsKxSceneDef</a></h2>
			<pre>type LibsKxSceneDef map[string]*LibKxSceneDefs</pre>
			<p>
The underlying type of the global AllKxSceneDefLibs variable:
a hash-table that contains LibKxSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxSceneDef.AddNew">func (LibsKxSceneDef) <a href="/target/kxscene.gt.go?s=4772:4836#L147">AddNew</a></h3>
				<pre>func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</pre>
				<p>
Creates a new LibKxSceneDefs library with the specified Id, adds it to this LibsKxSceneDef, and returns it.
If this LibsKxSceneDef already contains a LibKxSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsLightDef">type <a href="/target/light.gt.go?s=5697:5739#L197">LibsLightDef</a></h2>
			<pre>type LibsLightDef map[string]*LibLightDefs</pre>
			<p>
The underlying type of the global AllLightDefLibs variable:
a hash-table that contains LibLightDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsLightDef.AddNew">func (LibsLightDef) <a href="/target/light.gt.go?s=5965:6025#L201">AddNew</a></h3>
				<pre>func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</pre>
				<p>
Creates a new LibLightDefs library with the specified Id, adds it to this LibsLightDef, and returns it.
If this LibsLightDef already contains a LibLightDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=3685:3725#L134">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global AllNodeDefLibs variable:
a hash-table that contains LibNodeDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=3947:4005#L138">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new LibNodeDefs library with the specified Id, adds it to this LibsNodeDef, and returns it.
If this LibsNodeDef already contains a LibNodeDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=3145:3201#L96">LibsPxForceFieldDef</a></h2>
			<pre>type LibsPxForceFieldDef map[string]*LibPxForceFieldDefs</pre>
			<p>
The underlying type of the global AllPxForceFieldDefLibs variable:
a hash-table that contains LibPxForceFieldDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxForceFieldDef.AddNew">func (LibsPxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=3455:3529#L100">AddNew</a></h3>
				<pre>func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</pre>
				<p>
Creates a new LibPxForceFieldDefs library with the specified Id, adds it to this LibsPxForceFieldDef, and returns it.
If this LibsPxForceFieldDef already contains a LibPxForceFieldDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=3313:3365#L107">LibsPxMaterialDef</a></h2>
			<pre>type LibsPxMaterialDef map[string]*LibPxMaterialDefs</pre>
			<p>
The underlying type of the global AllPxMaterialDefLibs variable:
a hash-table that contains LibPxMaterialDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxMaterialDef.AddNew">func (LibsPxMaterialDef) <a href="/target/pxmaterial.gt.go?s=3611:3681#L111">AddNew</a></h3>
				<pre>func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</pre>
				<p>
Creates a new LibPxMaterialDefs library with the specified Id, adds it to this LibsPxMaterialDef, and returns it.
If this LibsPxMaterialDef already contains a LibPxMaterialDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxModelDef">type <a href="/target/pxmodel.gt.go?s=4324:4370#L122">LibsPxModelDef</a></h2>
			<pre>type LibsPxModelDef map[string]*LibPxModelDefs</pre>
			<p>
The underlying type of the global AllPxModelDefLibs variable:
a hash-table that contains LibPxModelDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxModelDef.AddNew">func (LibsPxModelDef) <a href="/target/pxmodel.gt.go?s=4604:4668#L126">AddNew</a></h3>
				<pre>func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</pre>
				<p>
Creates a new LibPxModelDefs library with the specified Id, adds it to this LibsPxModelDef, and returns it.
If this LibsPxModelDef already contains a LibPxModelDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxSceneDef">type <a href="/target/pxscene.gt.go?s=3500:3546#L112">LibsPxSceneDef</a></h2>
			<pre>type LibsPxSceneDef map[string]*LibPxSceneDefs</pre>
			<p>
The underlying type of the global AllPxSceneDefLibs variable:
a hash-table that contains LibPxSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxSceneDef.AddNew">func (LibsPxSceneDef) <a href="/target/pxscene.gt.go?s=3780:3844#L116">AddNew</a></h3>
				<pre>func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</pre>
				<p>
Creates a new LibPxSceneDefs library with the specified Id, adds it to this LibsPxSceneDef, and returns it.
If this LibsPxSceneDef already contains a LibPxSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=4769:4823#L160">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global AllVisualSceneDefLibs variable:
a hash-table that contains LibVisualSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=5073:5145#L164">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new LibVisualSceneDefs library with the specified Id, adds it to this LibsVisualSceneDef, and returns it.
If this LibsVisualSceneDef already contains a LibVisualSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LightAmbient">type <a href="/target/light.gt.go?s=149:198#L1">LightAmbient</a></h2>
			<pre>type LightAmbient struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes an ambient light source.
An ambient light is one that lights everything evenly, regardless of location or orientation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightAttenuation">type <a href="/target/light.gt.go?s=264:464#L1">LightAttenuation</a></h2>
			<pre>type LightAttenuation struct {
    <span class="comment">//	Constant light attenuation. Defaults to 1.</span>
    Constant SidFloat

    <span class="comment">//	Linear light attenuation.</span>
    Linear SidFloat

    <span class="comment">//	Quadratic light attenuation.</span>
    Quadratic SidFloat
}</pre>
			<p>
Describes how the intensity of a light source is attenuated.
</p>


			

			

			

			
				
				<h3 id="NewLightAttenuation">func <a href="/target/light.gt.go?s=481:530#L13">NewLightAttenuation</a></h3>
				<pre>func NewLightAttenuation() (me *LightAttenuation)</pre>
				<p>
Constructor
</p>

				
			

			
				
				<h3 id="LightAttenuation.AccessField">func (*LightAttenuation) <a href="/target/-gen-refsids.go?s=39303:39365#L1586">AccessField</a></h3>
				<pre>func (me *LightAttenuation) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Constant&#34;, &#34;Linear&#34;, &#34;Quadratic&#34;.
</p>

				
				
			
		
			
			
			<h2 id="LightBase">type <a href="/target/light.gt.go?s=663:771#L20">LightBase</a></h2>
			<pre>type LightBase struct {
    <span class="comment">//	Three floating-point numbers specifying the color of this light.</span>
    Color Float3
}</pre>
			<p>
Contains three floating-point numbers specifying the color of a light.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightDef">type <a href="/target/light.gt.go?s=2689:3184#L82">LightDef</a></h2>
			<pre>type LightDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Common-technique profile. At least and at most one of its fields should ever be set.</span>
    TC struct {
        <span class="comment">//	If set, this light declares an ambient light.</span>
        Ambient *LightAmbient

        <span class="comment">//	If set, this light declares a directional light.</span>
        Directional *LightDirectional

        <span class="comment">//	If set, this light declares a point light.</span>
        Point *LightPoint

        <span class="comment">//	If set, this light declares a spot light.</span>
        Spot *LightSpot
    }
}</pre>
			<p>
Declares a light source that illuminates a scene.
</p>


			

			

			

			

			
				
				<h3 id="LightDef.DefaultInst">func (*LightDef) <a href="/target/light.gt.go?s=3985:4036#L137">DefaultInst</a></h3>
				<pre>func (me *LightDef) DefaultInst() (inst *LightInst)</pre>
				<p>
Returns &#34;the default LightInst instance&#34; referencing this LightDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="LightDef.Init">func (*LightDef) <a href="/target/light.gt.go?s=3204:3230#L106">Init</a></h3>
				<pre>func (me *LightDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="LightDef.NewInst">func (*LightDef) <a href="/target/light.gt.go?s=4323:4370#L147">NewInst</a></h3>
				<pre>func (me *LightDef) NewInst() (inst *LightInst)</pre>
				<p>
Creates and returns a new LightInst instance referencing this LightDef definition.
Any LightInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="LightDirectional">type <a href="/target/light.gt.go?s=1135:1188#L29">LightDirectional</a></h2>
			<pre>type LightDirectional struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes a directional light source.
A directional light is one that lights everything from the same direction, regardless of location.
The light&#39;s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis.
The actual direction of the light is defined by the transform of the node where the light is instantiated.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightInst">type <a href="/target/light.gt.go?s=3270:3574#L110">LightInst</a></h2>
			<pre>type LightInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *LightDef
}</pre>
			<p>
Instantiates a light resource.
</p>


			

			

			

			

			
				
				<h3 id="LightInst.EnsureDef">func (*LightInst) <a href="/target/light.gt.go?s=4724:4766#L158">EnsureDef</a></h3>
				<pre>func (me *LightInst) EnsureDef() *LightDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct LightDef
according to the current me.DefRef value (by searching AllLightDefLibs).
Then returns me.Def.
(Note, every LightInst&#39;s Def is nil initially, unless it was created via LightDef.NewInst().)
</p>

				
				
			
				
				<h3 id="LightInst.Init">func (*LightInst) <a href="/target/light.gt.go?s=3594:3621#L121">Init</a></h3>
				<pre>func (me *LightInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="LightPoint">type <a href="/target/light.gt.go?s=1412:1593#L37">LightPoint</a></h2>
			<pre>type LightPoint struct {
    <span class="comment">//	Color</span>
    LightBase

    <span class="comment">//	The intensity of a point light source is attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation
}</pre>
			<p>
Describes a point light source.
A point light source radiates light in all directions from a known location in space.
The position of the light is defined by the transform of the node in which it is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightPoint">func <a href="/target/light.gt.go?s=1610:1647#L46">NewLightPoint</a></h3>
				<pre>func NewLightPoint() (me *LightPoint)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="LightSpot">type <a href="/target/light.gt.go?s=2071:2494#L56">LightSpot</a></h2>
			<pre>type LightSpot struct {
    <span class="comment">//	Color</span>
    LightBase

    <span class="comment">//	 The intensity of a spot light is also attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation

    <span class="comment">//	The light&#39;s intensity is also attenuated as the radiation angle increases away from the direction of the light source.</span>
    Falloff struct {
        <span class="comment">//	Fall-off angle. Defaults to 180.</span>
        Angle SidFloat

        <span class="comment">//	Fall-off exponent.</span>
        Exponent SidFloat
    }
}</pre>
			<p>
Describes a spot light source.
A spot light source radiates light in one direction in a cone shape from a known location in space.
The light&#39;s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis.
The actual direction of the light is defined by the transform of the node in which the light is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightSpot">func <a href="/target/light.gt.go?s=2511:2546#L74">NewLightSpot</a></h3>
				<pre>func NewLightSpot() (me *LightSpot)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="MaterialBinding">type <a href="/target/common.go?s=5421:5694#L198">MaterialBinding</a></h2>
			<pre>type MaterialBinding struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Targets for animation</span>
    Params []*Param

    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	References to the materials included in this material binding.</span>
        Materials []*FxMaterialInst
    }
}</pre>
			<p>
Binds a specific material to a piece of geometry,
binding varying and uniform parameters at the same time.
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=294:1034#L3">NodeDef</a></h2>
			<pre>type NodeDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Indicates whether this node is a joint for a skin controller.</span>
    IsSkinJoint bool

    <span class="comment">//	The names of the layers to which this node belongs.</span>
    Layers Layers

    <span class="comment">//	Any combination of zero or more transformations of any type.</span>
    Transforms []*Transform

    <span class="comment">//	Content resources participating in this node.</span>
    Insts struct {
        <span class="comment">//	Cameras participating in this node.</span>
        Camera []*CameraInst

        <span class="comment">//	Controllers participating in this node.</span>
        Controller []*ControllerInst

        <span class="comment">//	Geometries participating in this node.</span>
        Geometry []*GeometryInst

        <span class="comment">//	Lights participating in this node.</span>
        Light []*LightInst
    }
    <span class="comment">//	Child nodes to recursively define a hierarchy.</span>
    Nodes []ChildNode
}</pre>
			<p>
Declares a point of interest in a scene.
</p>


			

			

			

			

			
				
				<h3 id="NodeDef.AccessField">func (*NodeDef) <a href="/target/-gen-refsids.go?s=38361:38414#L1542">AccessField</a></h3>
				<pre>func (me *NodeDef) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;IsSkinJoint&#34;.
</p>

				
				
			
				
				<h3 id="NodeDef.DefaultInst">func (*NodeDef) <a href="/target/node.gt.go?s=2009:2058#L74">DefaultInst</a></h3>
				<pre>func (me *NodeDef) DefaultInst() (inst *NodeInst)</pre>
				<p>
Returns &#34;the default NodeInst instance&#34; referencing this NodeDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="NodeDef.Init">func (*NodeDef) <a href="/target/node.gt.go?s=1054:1079#L38">Init</a></h3>
				<pre>func (me *NodeDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="NodeDef.NewInst">func (*NodeDef) <a href="/target/node.gt.go?s=2340:2385#L84">NewInst</a></h3>
				<pre>func (me *NodeDef) NewInst() (inst *NodeInst)</pre>
				<p>
Creates and returns a new NodeInst instance referencing this NodeDef definition.
Any NodeInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=1140:1605#L43">NodeInst</a></h2>
			<pre>type NodeInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *NodeDef

    <span class="comment">//	Optional. The mechanism and use of this attribute is application-defined.</span>
    <span class="comment">//	For example, it can be used for bounding boxes or level of detail.</span>
    Proxy RefId
}</pre>
			<p>
Instantiates a node resource.
</p>


			

			

			

			

			
				
				<h3 id="NodeInst.AccessField">func (*NodeInst) <a href="/target/-gen-refsids.go?s=41248:41302#L1682">AccessField</a></h3>
				<pre>func (me *NodeInst) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Proxy&#34;.
</p>

				
				
			
				
				<h3 id="NodeInst.EnsureDef">func (*NodeInst) <a href="/target/node.gt.go?s=2734:2774#L95">EnsureDef</a></h3>
				<pre>func (me *NodeInst) EnsureDef() *NodeDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct NodeDef
according to the current me.DefRef value (by searching AllNodeDefLibs).
Then returns me.Def.
(Note, every NodeInst&#39;s Def is nil initially, unless it was created via NodeDef.NewInst().)
</p>

				
				
			
				
				<h3 id="NodeInst.Init">func (*NodeInst) <a href="/target/node.gt.go?s=1625:1651#L58">Init</a></h3>
				<pre>func (me *NodeInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Param">type <a href="/target/common.go?s=5756:5979#L216">Param</a></h2>
			<pre>type Param struct {
    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The user-defined meaning of the parameter.</span>
    Semantic string

    <span class="comment">//	The type of the value data. This text string must be understood by the application.</span>
    Type string
}</pre>
			<p>
Declares parametric information for its parent resource.
</p>


			

			

			

			

			
				
				<h3 id="Param.AccessField">func (*Param) <a href="/target/-gen-refsids.go?s=40628:40679#L1650">AccessField</a></h3>
				<pre>func (me *Param) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Semantic&#34;, &#34;Type&#34;.
</p>

				
				
			
		
			
			
			<h2 id="ParamDef">type <a href="/target/common.go?s=6067:6164#L231">ParamDef</a></h2>
			<pre>type ParamDef struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Initial value for this parameter</span>
    Value interface{}
}</pre>
			<p>
Declares a new parameter for its parent resource, and assigns it an initial value.
</p>


			

			

			

			

			
				
				<h3 id="ParamDef.AccessField">func (*ParamDef) <a href="/target/-gen-refsids.go?s=40427:40481#L1640">AccessField</a></h3>
				<pre>func (me *ParamDef) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Value&#34;.
</p>

				
				
			
		
			
			
			<h2 id="ParamDefs">type <a href="/target/common.go?s=6234:6269#L240">ParamDefs</a></h2>
			<pre>type ParamDefs map[string]*ParamDef</pre>
			<p>
A hash-table containing parameter declarations of this resource.
</p>


			

			

			

			

			
				
				<h3 id="ParamDefs.Set">func (ParamDefs) <a href="/target/common.go?s=6418:6470#L244">Set</a></h3>
				<pre>func (me ParamDefs) Set(sid string, val interface{})</pre>
				<p>
If me does not contain a ParamDef with the specified Sid, adds it.
Next, sets the value of the ParamDef with the specified Sid in me to val.
</p>

				
				
			
		
			
			
			<h2 id="ParamInst">type <a href="/target/common.go?s=6631:6953#L254">ParamInst</a></h2>
			<pre>type ParamInst struct {
    <span class="comment">//	References the identifier of the pre-defined parameter (ParamDef) that will have its value set.</span>
    Ref RefSid

    <span class="comment">//	Indicates if the Value is a string referencing the identifier of a connected parameter.</span>
    IsConnectParamRef bool

    <span class="comment">//	The new value for the referenced parameter.</span>
    Value interface{}
}</pre>
			<p>
Assigns a new value to a previously defined parameter.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamInsts">type <a href="/target/common.go?s=7026:7063#L266">ParamInsts</a></h2>
			<pre>type ParamInsts map[string]*ParamInst</pre>
			<p>
A hash-table containing parameter values assigned by this resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrBool">type <a href="/target/types.go?s=5020:5188#L232">ParamOrBool</a></h2>
			<pre>type ParamOrBool struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    B bool

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a bool value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrFloat">type <a href="/target/types.go?s=5219:5391#L241">ParamOrFloat</a></h2>
			<pre>type ParamOrFloat struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    F float64

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrFloat2">type <a href="/target/types.go?s=5425:5599#L250">ParamOrFloat2</a></h2>
			<pre>type ParamOrFloat2 struct {
    <span class="comment">//	The values provided if Param is empty.</span>
    F Float2

    <span class="comment">//	If set, refers to a previously defined parameter providing the values.</span>
    Param RefParam
}</pre>
			<p>
Provides two float64 values.
</p>


			

			

			

			

			
				
				<h3 id="ParamOrFloat2.AccessIndex">func (*ParamOrFloat2) <a href="/target/types.go?s=5671:5729#L260">AccessIndex</a></h3>
				<pre>func (me *ParamOrFloat2) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="ParamOrInt">type <a href="/target/types.go?s=5779:5947#L265">ParamOrInt</a></h2>
			<pre>type ParamOrInt struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    I int64

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a int64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrRefSid">type <a href="/target/types.go?s=6191:6364#L283">ParamOrRefSid</a></h2>
			<pre>type ParamOrRefSid struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    Sr RefSid

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a RefSid value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrSidFloat">type <a href="/target/types.go?s=5985:6161#L274">ParamOrSidFloat</a></h2>
			<pre>type ParamOrSidFloat struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    F SidFloat

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a scoped float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrUint">type <a href="/target/types.go?s=6394:6564#L292">ParamOrUint</a></h2>
			<pre>type ParamOrUint struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    U uint64

    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a uint64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxCylinder">type <a href="/target/pxrigidbody.go?s=179:359#L1">PxCylinder</a></h2>
			<pre>type PxCylinder struct {
    <span class="comment">//	Radii, Extras</span>
    GeometryBrepCylinder

    <span class="comment">//	Contains a floating-point value that represents the length of the cylinder along the y axis.</span>
    Height float64
}</pre>
			<p>
Declares a cylinder primitive that is centered around its local origin
and aligned along its local y axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=205:304#L1">PxForceFieldDef</a></h2>
			<pre>type PxForceFieldDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Techniques</span>
    HasTechniques
}</pre>
			<p>
Provides a general container for force fields.
Force fields affect physical objects, such as rigid bodies, and
may be instantiated under a physics scene or a physics model instance.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldDef.DefaultInst">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=1181:1246#L36">DefaultInst</a></h3>
				<pre>func (me *PxForceFieldDef) DefaultInst() (inst *PxForceFieldInst)</pre>
				<p>
Returns &#34;the default PxForceFieldInst instance&#34; referencing this PxForceFieldDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="PxForceFieldDef.Init">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=324:357#L5">Init</a></h3>
				<pre>func (me *PxForceFieldDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxForceFieldDef.NewInst">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=1568:1629#L46">NewInst</a></h3>
				<pre>func (me *PxForceFieldDef) NewInst() (inst *PxForceFieldInst)</pre>
				<p>
Creates and returns a new PxForceFieldInst instance referencing this PxForceFieldDef definition.
Any PxForceFieldInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="PxForceFieldInst">type <a href="/target/pxforcefield.gt.go?s=403:721#L9">PxForceFieldInst</a></h2>
			<pre>type PxForceFieldInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxForceFieldDef
}</pre>
			<p>
Instantiates a force field resource.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldInst.EnsureDef">func (*PxForceFieldInst) <a href="/target/pxforcefield.gt.go?s=2018:2074#L57">EnsureDef</a></h3>
				<pre>func (me *PxForceFieldInst) EnsureDef() *PxForceFieldDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct PxForceFieldDef
according to the current me.DefRef value (by searching AllPxForceFieldDefLibs).
Then returns me.Def.
(Note, every PxForceFieldInst&#39;s Def is nil initially, unless it was created via PxForceFieldDef.NewInst().)
</p>

				
				
			
				
				<h3 id="PxForceFieldInst.Init">func (*PxForceFieldInst) <a href="/target/pxforcefield.gt.go?s=741:775#L20">Init</a></h3>
				<pre>func (me *PxForceFieldInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxMaterial">type <a href="/target/pxrigidbody.go?s=513:685#L9">PxMaterial</a></h2>
			<pre>type PxMaterial struct {
    <span class="comment">//	An inline physics material definition.</span>
    Def *PxMaterialDef

    <span class="comment">//	Instantiation of a previously defined physics material.</span>
    Inst *PxMaterialInst
}</pre>
			<p>
Describes the physical surface properties for a rigid body or one of its shapes.
Either Def or Inst (or none), but not both, should be specified.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=63:512#L1">PxMaterialDef</a></h2>
			<pre>type PxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	The dynamic friction coefficient.</span>
        DynamicFriction SidFloat

        <span class="comment">//	The proportion of the kinetic energy preserved in the impact</span>
        <span class="comment">//	(typically ranges from 0.0 to 1.0). Also known as &#34;bounciness&#34; or &#34;elasticity.&#34;</span>
        Restitution SidFloat

        <span class="comment">//	The static friction coefficient.</span>
        StaticFriction SidFloat
    }
}</pre>
			<p>
Defines the physical properties of an object.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialDef.DefaultInst">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=1421:1482#L47">DefaultInst</a></h3>
				<pre>func (me *PxMaterialDef) DefaultInst() (inst *PxMaterialInst)</pre>
				<p>
Returns &#34;the default PxMaterialInst instance&#34; referencing this PxMaterialDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="PxMaterialDef.Init">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=532:563#L16">Init</a></h3>
				<pre>func (me *PxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxMaterialDef.NewInst">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=1794:1851#L57">NewInst</a></h3>
				<pre>func (me *PxMaterialDef) NewInst() (inst *PxMaterialInst)</pre>
				<p>
Creates and returns a new PxMaterialInst instance referencing this PxMaterialDef definition.
Any PxMaterialInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="PxMaterialInst">type <a href="/target/pxmaterial.gt.go?s=661:975#L20">PxMaterialInst</a></h2>
			<pre>type PxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxMaterialDef
}</pre>
			<p>
Lets a shape specify its surface properties using a previously defined physics material.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialInst.EnsureDef">func (*PxMaterialInst) <a href="/target/pxmaterial.gt.go?s=2230:2282#L68">EnsureDef</a></h3>
				<pre>func (me *PxMaterialInst) EnsureDef() *PxMaterialDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct PxMaterialDef
according to the current me.DefRef value (by searching AllPxMaterialDefLibs).
Then returns me.Def.
(Note, every PxMaterialInst&#39;s Def is nil initially, unless it was created via PxMaterialDef.NewInst().)
</p>

				
				
			
				
				<h3 id="PxMaterialInst.Init">func (*PxMaterialInst) <a href="/target/pxmaterial.gt.go?s=995:1027#L31">Init</a></h3>
				<pre>func (me *PxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxModelDef">type <a href="/target/pxmodel.gt.go?s=134:544#L1">PxModelDef</a></h2>
			<pre>type PxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Contains zero or more rigid bodies participating in this physics model.</span>
    RigidBodies PxRigidBodyDefs

    <span class="comment">//	Contains zero or more rigid constraints participating in this physics model.</span>
    RigidConstraints PxRigidConstraintDefs

    <span class="comment">//	Child physics models participating in this physics model, with optional property overrides.</span>
    Insts []*PxModelInst
}</pre>
			<p>
Allows for building complex combinations of rigid bodies and constraints
that may be instantiated multiple times.
</p>


			

			

			

			

			
				
				<h3 id="PxModelDef.DefaultInst">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=2540:2595#L62">DefaultInst</a></h3>
				<pre>func (me *PxModelDef) DefaultInst() (inst *PxModelInst)</pre>
				<p>
Returns &#34;the default PxModelInst instance&#34; referencing this PxModelDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="PxModelDef.Init">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=564:592#L10">Init</a></h3>
				<pre>func (me *PxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxModelDef.NewInst">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=2892:2943#L72">NewInst</a></h3>
				<pre>func (me *PxModelDef) NewInst() (inst *PxModelInst)</pre>
				<p>
Creates and returns a new PxModelInst instance referencing this PxModelDef definition.
Any PxModelInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="PxModelInst">type <a href="/target/pxmodel.gt.go?s=795:2115#L17">PxModelInst</a></h2>
			<pre>type PxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxModelDef

    <span class="comment">//	Points to the Id of a node in the visual scene. This allows a physics model to be instantiated</span>
    <span class="comment">//	under a specific transform node, which will dictate the initial position and orientation,</span>
    <span class="comment">//	and could be animated to influence kinematic rigid bodies. Optional.</span>
    <span class="comment">//	By default, the physics model is instantiated under the world, rather than a specific transform node.</span>
    <span class="comment">//	This parameter is only meaningful when the parent element of the current physics model is a physics scene.</span>
    Parent RefId

    <span class="comment">//	Zero or more force fields influencing this physics model.</span>
    ForceFields []*PxForceFieldInst

    <span class="comment">//	Contains instances of those rigid bodies included in the instantiated physics model that should</span>
    <span class="comment">//	have some properties overridden, or should be linked with transform nodes in the visual scene.</span>
    RigidBodies []*PxRigidBodyInst

    <span class="comment">//	Contains instances of those rigid constraints included in the instantiated</span>
    <span class="comment">//	physics model that should have some properties overridden.</span>
    RigidConstraints []*PxRigidConstraintInst
}</pre>
			<p>
Embeds a physics model inside another physics model or
instantiates a physics model within a physics scene.
</p>


			

			

			

			

			
				
				<h3 id="PxModelInst.AccessField">func (*PxModelInst) <a href="/target/-gen-refsids.go?s=40854:40911#L1662">AccessField</a></h3>
				<pre>func (me *PxModelInst) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Parent&#34;.
</p>

				
				
			
				
				<h3 id="PxModelInst.EnsureDef">func (*PxModelInst) <a href="/target/pxmodel.gt.go?s=3307:3353#L83">EnsureDef</a></h3>
				<pre>func (me *PxModelInst) EnsureDef() *PxModelDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct PxModelDef
according to the current me.DefRef value (by searching AllPxModelDefLibs).
Then returns me.Def.
(Note, every PxModelInst&#39;s Def is nil initially, unless it was created via PxModelDef.NewInst().)
</p>

				
				
			
				
				<h3 id="PxModelInst.Init">func (*PxModelInst) <a href="/target/pxmodel.gt.go?s=2135:2164#L46">Init</a></h3>
				<pre>func (me *PxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyCommon">type <a href="/target/pxrigidbody.go?s=1885:2775#L59">PxRigidBodyCommon</a></h2>
			<pre>type PxRigidBodyCommon struct {
    <span class="comment">//	Specifies whether this rigid body is movable. Defaults to true.</span>
    Dynamic SidBool

    <span class="comment">//	If set, specifies the total mass of this rigid body.</span>
    Mass *SidFloat

    <span class="comment">//	Zero or more TransformKindRotate and/or TransformKindTranslate transformations defining the</span>
    <span class="comment">//	center and orientation of mass of the rigid-body relative to the local origin of the &#34;root&#34; shape.</span>
    <span class="comment">//	This makes the off-diagonal elements of the inertia tensor (products of inertia) all 0</span>
    <span class="comment">//	and allows us to just store the diagonal elements (moments of inertia).</span>
    MassFrame []*Transform

    <span class="comment">//	The diagonal elements of the inertia tensor (moments of inertia),</span>
    <span class="comment">//	represented in the local frame of the center of mass.</span>
    Inertia *SidFloat3

    <span class="comment">//	Describes the physical surface properties for this rigid body.</span>
    Material PxMaterial

    <span class="comment">//	Zero or more shapes for collision detection.</span>
    Shapes []*PxShape
}</pre>
			<p>
Common-technique profile for rigid body definitions and instances.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidBodyCommon.AccessField">func (*PxRigidBodyCommon) <a href="/target/-gen-refsids.go?s=41773:41836#L1706">AccessField</a></h3>
				<pre>func (me *PxRigidBodyCommon) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Dynamic&#34;.
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyDef">type <a href="/target/pxrigidbody.go?s=2954:3192#L87">PxRigidBodyDef</a></h2>
			<pre>type PxRigidBodyDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
        PxRigidBodyCommon
    }
}</pre>
			<p>
Describes simulated bodies that do not deform.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidBodyDef.Init">func (*PxRigidBodyDef) <a href="/target/pxrigidbody.go?s=3212:3244#L105">Init</a></h3>
				<pre>func (me *PxRigidBodyDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyDefs">type <a href="/target/pxrigidbody.go?s=2855:2902#L84">PxRigidBodyDefs</a></h2>
			<pre>type PxRigidBodyDefs map[string]*PxRigidBodyDef</pre>
			<p>
A hash-table of rigid body definitions mapped to their scoped identifiers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidBodyInst">type <a href="/target/pxrigidbody.go?s=3313:4105#L110">PxRigidBodyInst</a></h2>
			<pre>type PxRigidBodyInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxRigidBodyDef

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Refers to the NodeDef influenced by this rigid body instance.</span>
    TargetNode RefId

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
        PxRigidBodyCommon

        <span class="comment">//	Initial spin or angular velocity, also known as the axis of rotation,</span>
        <span class="comment">//	with a magnitude equal to the rate of rotation in radians per second.</span>
        AngularVelocity unum.Vec3

        <span class="comment">//	Initial linear velocity.</span>
        LinearVelocity unum.Vec3
    }
}</pre>
			<p>
Instantiates a rigid-body resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidBodyInst.AccessField">func (*PxRigidBodyInst) <a href="/target/-gen-refsids.go?s=40008:40069#L1620">AccessField</a></h3>
				<pre>func (me *PxRigidBodyInst) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;TargetNode&#34;.
</p>

				
				
			
				
				<h3 id="PxRigidBodyInst.Init">func (*PxRigidBodyInst) <a href="/target/pxrigidbody.go?s=4125:4158#L140">Init</a></h3>
				<pre>func (me *PxRigidBodyInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintAttachment">type <a href="/target/pxrigidconstraint.go?s=138:601#L1">PxRigidConstraintAttachment</a></h2>
			<pre>type PxRigidConstraintAttachment struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Refers to a RigidBodyDef or NodeDef.</span>
    RigidBody RefSid

    <span class="comment">//	Zero or more translation and/or rotation transformations:</span>
    <span class="comment">//	The position of a TransformKindTranslate Transform indicates</span>
    <span class="comment">//	the attachment point on the corresponding RigidBodyDef.</span>
    <span class="comment">//	The orientation of a TransformKindRotate Transform indicates</span>
    <span class="comment">//	the alignment of the joint frame for that RigidBodyDef.</span>
    Transforms []*Transform
}</pre>
			<p>
Defines an attachment frame (or attachment frame of reference),
to a rigid body or a node, within a rigid constraint.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintDef">type <a href="/target/pxrigidconstraint.go?s=1515:2657#L43">PxRigidConstraintDef</a></h2>
			<pre>type PxRigidConstraintDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Defines the attachment frame of reference (to a rigid body or a node) within this rigid constraint.</span>
    RefAttachment PxRigidConstraintAttachment

    <span class="comment">//	Defines an attachment frame (to a rigid body or a node) within this rigid constraint.</span>
    Attachment PxRigidConstraintAttachment

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	If false, this rigid constraint doesn&#39;t exert any force or influence on the rigid bodies.</span>
        Enabled SidBool

        <span class="comment">//	If true, the attached rigid bodies may interpenetrate.</span>
        Interpenetrate SidBool

        <span class="comment">//	Degrees of freedom and ranges.</span>
        Limits struct {
            <span class="comment">//	Describes the angular limits along each rotation axis in degrees.</span>
            Angular *PxRigidConstraintLimit

            <span class="comment">//	Describes linear (translational) limits along each axis.</span>
            Linear *PxRigidConstraintLimit
        }
        <span class="comment">//	Spring is based based on either distance (Linear) or angle (Angular), or both.</span>
        Spring struct {
            <span class="comment">//	Angle-based spring.</span>
            Angular *PxRigidConstraintSpring

            <span class="comment">//	Distance-based spring.</span>
            Linear *PxRigidConstraintSpring
        }
    }
}</pre>
			<p>
Constrains rigid bodies to each other or to the world.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintDef.Init">func (*PxRigidConstraintDef) <a href="/target/pxrigidconstraint.go?s=2677:2715#L87">Init</a></h3>
				<pre>func (me *PxRigidConstraintDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintDefs">type <a href="/target/pxrigidconstraint.go?s=1396:1455#L40">PxRigidConstraintDefs</a></h2>
			<pre>type PxRigidConstraintDefs map[string]*PxRigidConstraintDef</pre>
			<p>
A hash-table of rigid constraint definitions mapped to their scoped identifiers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintInst">type <a href="/target/pxrigidconstraint.go?s=2790:3118#L92">PxRigidConstraintInst</a></h2>
			<pre>type PxRigidConstraintInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxRigidConstraintDef
}</pre>
			<p>
Instantiates a rigid constraint resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintInst.Init">func (*PxRigidConstraintInst) <a href="/target/pxrigidconstraint.go?s=3138:3177#L103">Init</a></h3>
				<pre>func (me *PxRigidConstraintInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintLimit">type <a href="/target/pxrigidconstraint.go?s=637:804#L11">PxRigidConstraintLimit</a></h2>
			<pre>type PxRigidConstraintLimit struct {
    <span class="comment">//	Lower bounds for this limit across all 3 axes.</span>
    Min SidVec3

    <span class="comment">//	Upper bounds for this limit across all 3 axes.</span>
    Max SidVec3
}</pre>
			<p>
Degrees of freedom and ranges.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintLimit.AccessField">func (*PxRigidConstraintLimit) <a href="/target/-gen-refsids.go?s=39037:39105#L1574">AccessField</a></h3>
				<pre>func (me *PxRigidConstraintLimit) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Min&#34;, &#34;Max&#34;.
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintSpring">type <a href="/target/pxrigidconstraint.go?s=888:1165#L20">PxRigidConstraintSpring</a></h2>
			<pre>type PxRigidConstraintSpring struct {
    <span class="comment">//	Also called spring coefficient.</span>
    <span class="comment">//	Has units of force/distance (for Linear) or force/angle (for Angular).</span>
    Stiffness SidFloat

    <span class="comment">//	How this spring is damped.</span>
    Damping SidFloat

    <span class="comment">//	Target value for this spring.</span>
    TargetValue SidFloat
}</pre>
			<p>
Spring is based based on either distance (Linear) or angle (Angular), or both.
</p>


			

			

			

			
				
				<h3 id="NewPxRigidConstraintSpring">func <a href="/target/pxrigidconstraint.go?s=1182:1245#L33">NewPxRigidConstraintSpring</a></h3>
				<pre>func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</pre>
				<p>
Constructor
</p>

				
			

			
				
				<h3 id="PxRigidConstraintSpring.AccessField">func (*PxRigidConstraintSpring) <a href="/target/-gen-refsids.go?s=41468:41537#L1692">AccessField</a></h3>
				<pre>func (me *PxRigidConstraintSpring) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Stiffness&#34;, &#34;Damping&#34;, &#34;TargetValue&#34;.
</p>

				
				
			
		
			
			
			<h2 id="PxSceneDef">type <a href="/target/pxscene.gt.go?s=100:887#L1">PxSceneDef</a></h2>
			<pre>type PxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	Force fields influencing this physics scene.</span>
    ForceFields []*PxForceFieldInst

    <span class="comment">//	Refers to the rigid bodies and constraints participating in this scene.</span>
    Models []*PxModelInst

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	If set, a vector representation of this physics scene&#39;s gravity force field.</span>
        <span class="comment">//	It is given as a denormalized direction vector of three floating-point values that</span>
        <span class="comment">//	indicate both the magnitude and direction of acceleration caused by the field.</span>
        Gravity *SidVec3

        <span class="comment">//	If set, the integration time step, measured in seconds, of the physics scene.</span>
        <span class="comment">//	This value is engine-specific. If omitted, the physics engine&#39;s default is used.</span>
        TimeStep *SidFloat
    }
}</pre>
			<p>
Specifies an environment in which physical objects are instantiated and simulated.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneDef.DefaultInst">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=1716:1771#L52">DefaultInst</a></h3>
				<pre>func (me *PxSceneDef) DefaultInst() (inst *PxSceneInst)</pre>
				<p>
Returns &#34;the default PxSceneInst instance&#34; referencing this PxSceneDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="PxSceneDef.Init">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=907:935#L21">Init</a></h3>
				<pre>func (me *PxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxSceneDef.NewInst">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=2068:2119#L62">NewInst</a></h3>
				<pre>func (me *PxSceneDef) NewInst() (inst *PxSceneInst)</pre>
				<p>
Creates and returns a new PxSceneInst instance referencing this PxSceneDef definition.
Any PxSceneInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="PxSceneInst">type <a href="/target/pxscene.gt.go?s=983:1291#L25">PxSceneInst</a></h2>
			<pre>type PxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxSceneDef
}</pre>
			<p>
Instantiates a physics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneInst.EnsureDef">func (*PxSceneInst) <a href="/target/pxscene.gt.go?s=2483:2529#L73">EnsureDef</a></h3>
				<pre>func (me *PxSceneInst) EnsureDef() *PxSceneDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct PxSceneDef
according to the current me.DefRef value (by searching AllPxSceneDefLibs).
Then returns me.Def.
(Note, every PxSceneInst&#39;s Def is nil initially, unless it was created via PxSceneDef.NewInst().)
</p>

				
				
			
				
				<h3 id="PxSceneInst.Init">func (*PxSceneInst) <a href="/target/pxscene.gt.go?s=1311:1340#L36">Init</a></h3>
				<pre>func (me *PxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxShape">type <a href="/target/pxrigidbody.go?s=780:1813#L18">PxShape</a></h2>
			<pre>type PxShape struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	If true, the mass is distributed along the surface of this shape.</span>
    Hollow SidBool

    <span class="comment">//	The mass of this shape.</span>
    Mass *SidFloat

    <span class="comment">//	The density of this shape.</span>
    Density *SidFloat

    <span class="comment">//	Describes the physical surface properties for this shape.</span>
    Material PxMaterial

    <span class="comment">//	Geometry of the shape. At least and at most one of its fields should ever be set.</span>
    Geometry struct {
        <span class="comment">//	A flat plane.</span>
        Plane *GeometryBrepPlane

        <span class="comment">//	Axis-aligned box.</span>
        Box *GeometryBrepBox

        <span class="comment">//	A perfectly round sphere.</span>
        Sphere *GeometryBrepSphere

        <span class="comment">//	A cylinder primitive that is centered on its local origin and aligned along its y axis.</span>
        Cylinder *PxCylinder

        <span class="comment">//	A capsule primitive that is centered on the local origin and aligned along the y axis.</span>
        Capsule *GeometryBrepCapsule

        <span class="comment">//	Refers to a previously defined mesh or spline geometric primitive.</span>
        Inst *GeometryInst
    }
    <span class="comment">//	Zero or more TransformKindRotate and/or TransformKindTranslate transformations for the shape.</span>
    Transforms []*Transform
}</pre>
			<p>
A component part of a rigid body&#39;s collection of bounding shapes for collision detection.
</p>


			

			

			

			

			
				
				<h3 id="PxShape.AccessField">func (*PxShape) <a href="/target/-gen-refsids.go?s=39810:39863#L1610">AccessField</a></h3>
				<pre>func (me *PxShape) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Hollow&#34;.
</p>

				
				
			
		
			
			
			<h2 id="RefId">type <a href="/target/refid.go?s=70:87#L1">RefId</a></h2>
			<pre>type RefId string</pre>
			<p>
References a resource by its unique identifier (Id).
</p>


			

			

			

			

			
				
				<h3 id="RefId.AnimationClipDef">func (RefId) <a href="/target/animationclip.gt.go?s=3043:3101#L92">AnimationClipDef</a></h3>
				<pre>func (me RefId) AnimationClipDef() (def *AnimationClipDef)</pre>
				<p>
Searches (all LibAnimationClipDefs contained in AllAnimationClipDefLibs) for the AnimationClipDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.AnimationDef">func (RefId) <a href="/target/animation.gt.go?s=4487:4537#L142">AnimationDef</a></h3>
				<pre>func (me RefId) AnimationDef() (def *AnimationDef)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the AnimationDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.AnimationSampler">func (RefId) <a href="/target/refid.go?s=248:305#L1">AnimationSampler</a></h3>
				<pre>func (me RefId) AnimationSampler() (as *AnimationSampler)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the AnimationSampler
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInAnimationDef">func (RefId) <a href="/target/refid.go?s=689:739#L18">ArrayInAnimationDef</a></h3>
				<pre>func (me RefId) ArrayInAnimationDef() *SourceArray</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInAnyDef">func (RefId) <a href="/target/refid.go?s=1109:1162#L37">ArrayInAnyDef</a></h3>
				<pre>func (me RefId) ArrayInAnyDef() (srcArr *SourceArray)</pre>
				<p>
Calls the ArrayInAnimationDef(), ArrayInControllerDef() and ArrayInGeometryDef() methods in that order to find srcArr.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInControllerDef">func (RefId) <a href="/target/refid.go?s=1487:1538#L48">ArrayInControllerDef</a></h3>
				<pre>func (me RefId) ArrayInControllerDef() *SourceArray</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInGeometryDef">func (RefId) <a href="/target/refid.go?s=2097:2151#L76">ArrayInGeometryDef</a></h3>
				<pre>func (me RefId) ArrayInGeometryDef() (sa *SourceArray)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.CameraDef">func (RefId) <a href="/target/camera.gt.go?s=3771:3815#L139">CameraDef</a></h3>
				<pre>func (me RefId) CameraDef() (def *CameraDef)</pre>
				<p>
Searches (all LibCameraDefs contained in AllCameraDefLibs) for the CameraDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ControllerDef">func (RefId) <a href="/target/controller.gt.go?s=4726:4778#L157">ControllerDef</a></h3>
				<pre>func (me RefId) ControllerDef() (def *ControllerDef)</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the ControllerDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FormulaDef">func (RefId) <a href="/target/formula.gt.go?s=3026:3072#L112">FormulaDef</a></h3>
				<pre>func (me RefId) FormulaDef() (def *FormulaDef)</pre>
				<p>
Searches (all LibFormulaDefs contained in AllFormulaDefLibs) for the FormulaDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxEffectDef">func (RefId) <a href="/target/fxeffect.gt.go?s=18291:18339#L621">FxEffectDef</a></h3>
				<pre>func (me RefId) FxEffectDef() (def *FxEffectDef)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxEffectDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxImageDef">func (RefId) <a href="/target/fximage.gt.go?s=12851:12897#L399">FxImageDef</a></h3>
				<pre>func (me RefId) FxImageDef() (def *FxImageDef)</pre>
				<p>
Searches (all LibFxImageDefs contained in AllFxImageDefLibs) for the FxImageDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxMaterialDef">func (RefId) <a href="/target/fxmaterial.gt.go?s=3589:3641#L112">FxMaterialDef</a></h3>
				<pre>func (me RefId) FxMaterialDef() (def *FxMaterialDef)</pre>
				<p>
Searches (all LibFxMaterialDefs contained in AllFxMaterialDefLibs) for the FxMaterialDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxProfile">func (RefId) <a href="/target/refid.go?s=3683:3726#L136">FxProfile</a></h3>
				<pre>func (me RefId) FxProfile() (fp *FxProfile)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxProfile
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxTechniqueCommon">func (RefId) <a href="/target/refid.go?s=4112:4166#L156">FxTechniqueCommon</a></h3>
				<pre>func (me RefId) FxTechniqueCommon() *FxTechniqueCommon</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxTechniqueCommon
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxTechniqueGlsl">func (RefId) <a href="/target/refid.go?s=4621:4675#L176">FxTechniqueGlsl</a></h3>
				<pre>func (me RefId) FxTechniqueGlsl() (t *FxTechniqueGlsl)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxTechniqueGlsl
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepEdges">func (RefId) <a href="/target/refid.go?s=5164:5218#L201">GeometryBrepEdges</a></h3>
				<pre>func (me RefId) GeometryBrepEdges() *GeometryBrepEdges</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepEdges
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepFaces">func (RefId) <a href="/target/refid.go?s=5629:5683#L218">GeometryBrepFaces</a></h3>
				<pre>func (me RefId) GeometryBrepFaces() *GeometryBrepFaces</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepFaces
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepPcurves">func (RefId) <a href="/target/refid.go?s=6096:6154#L235">GeometryBrepPcurves</a></h3>
				<pre>func (me RefId) GeometryBrepPcurves() *GeometryBrepPcurves</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepPcurves
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepShells">func (RefId) <a href="/target/refid.go?s=6572:6628#L252">GeometryBrepShells</a></h3>
				<pre>func (me RefId) GeometryBrepShells() *GeometryBrepShells</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepShells
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepSolids">func (RefId) <a href="/target/refid.go?s=7043:7099#L269">GeometryBrepSolids</a></h3>
				<pre>func (me RefId) GeometryBrepSolids() *GeometryBrepSolids</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepSolids
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepWires">func (RefId) <a href="/target/refid.go?s=8367:8421#L314">GeometryBrepWires</a></h3>
				<pre>func (me RefId) GeometryBrepWires() *GeometryBrepWires</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepWires
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryDef">func (RefId) <a href="/target/geometry.gt.go?s=6651:6699#L225">GeometryDef</a></h3>
				<pre>func (me RefId) GeometryDef() (def *GeometryDef)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryMesh">func (RefId) <a href="/target/refid.go?s=7519:7568#L286">GeometryMesh</a></h3>
				<pre>func (me RefId) GeometryMesh() (gm *GeometryMesh)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryDef
whose Id is referenced by me, returning the Mesh of the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryVertices">func (RefId) <a href="/target/refid.go?s=7800:7852#L295">GeometryVertices</a></h3>
				<pre>func (me RefId) GeometryVertices() *GeometryVertices</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryVertices
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxArticulatedSystemDef">func (RefId) <a href="/target/kxarticulatedsystem.gt.go?s=9336:9406#L333">KxArticulatedSystemDef</a></h3>
				<pre>func (me RefId) KxArticulatedSystemDef() (def *KxArticulatedSystemDef)</pre>
				<p>
Searches (all LibKxArticulatedSystemDefs contained in AllKxArticulatedSystemDefLibs) for the KxArticulatedSystemDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxJointDef">func (RefId) <a href="/target/kxjoint.gt.go?s=3889:3935#L130">KxJointDef</a></h3>
				<pre>func (me RefId) KxJointDef() (def *KxJointDef)</pre>
				<p>
Searches (all LibKxJointDefs contained in AllKxJointDefLibs) for the KxJointDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxModelDef">func (RefId) <a href="/target/kxmodel.gt.go?s=4288:4334#L152">KxModelDef</a></h3>
				<pre>func (me RefId) KxModelDef() (def *KxModelDef)</pre>
				<p>
Searches (all LibKxModelDefs contained in AllKxModelDefLibs) for the KxModelDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxSceneDef">func (RefId) <a href="/target/kxscene.gt.go?s=4181:4227#L131">KxSceneDef</a></h3>
				<pre>func (me RefId) KxSceneDef() (def *KxSceneDef)</pre>
				<p>
Searches (all LibKxSceneDefs contained in AllKxSceneDefLibs) for the KxSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.LightDef">func (RefId) <a href="/target/light.gt.go?s=5396:5438#L185">LightDef</a></h3>
				<pre>func (me RefId) LightDef() (def *LightDef)</pre>
				<p>
Searches (all LibLightDefs contained in AllLightDefLibs) for the LightDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.NodeDef">func (RefId) <a href="/target/node.gt.go?s=3389:3429#L122">NodeDef</a></h3>
				<pre>func (me RefId) NodeDef() (def *NodeDef)</pre>
				<p>
Searches (all LibNodeDefs contained in AllNodeDefLibs) for the NodeDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxForceFieldDef">func (RefId) <a href="/target/pxforcefield.gt.go?s=2809:2865#L84">PxForceFieldDef</a></h3>
				<pre>func (me RefId) PxForceFieldDef() (def *PxForceFieldDef)</pre>
				<p>
Searches (all LibPxForceFieldDefs contained in AllPxForceFieldDefLibs) for the PxForceFieldDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxMaterialDef">func (RefId) <a href="/target/pxmaterial.gt.go?s=2987:3039#L95">PxMaterialDef</a></h3>
				<pre>func (me RefId) PxMaterialDef() (def *PxMaterialDef)</pre>
				<p>
Searches (all LibPxMaterialDefs contained in AllPxMaterialDefLibs) for the PxMaterialDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxModelDef">func (RefId) <a href="/target/pxmodel.gt.go?s=4013:4059#L110">PxModelDef</a></h3>
				<pre>func (me RefId) PxModelDef() (def *PxModelDef)</pre>
				<p>
Searches (all LibPxModelDefs contained in AllPxModelDefLibs) for the PxModelDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxSceneDef">func (RefId) <a href="/target/pxscene.gt.go?s=3189:3235#L100">PxSceneDef</a></h3>
				<pre>func (me RefId) PxSceneDef() (def *PxSceneDef)</pre>
				<p>
Searches (all LibPxSceneDefs contained in AllPxSceneDefLibs) for the PxSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.S">func (RefId) <a href="/target/refid.go?s=8720:8746#L330">S</a></h3>
				<pre>func (me RefId) S() string</pre>
				<p>
Returns the Id currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefId.SetIdRef">func (*RefId) <a href="/target/refid.go?s=8852:8887#L335">SetIdRef</a></h3>
				<pre>func (me *RefId) SetIdRef(v string)</pre>
				<p>
Modifies the Id currently referenced by me. This is a mere string assignment.
</p>

				
				
			
				
				<h3 id="RefId.SourceInAnimationDef">func (RefId) <a href="/target/refid.go?s=9058:9108#L341">SourceInAnimationDef</a></h3>
				<pre>func (me RefId) SourceInAnimationDef() (s *Source)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.SourceInAnyDef">func (RefId) <a href="/target/refid.go?s=9422:9468#L357">SourceInAnyDef</a></h3>
				<pre>func (me RefId) SourceInAnyDef() (src *Source)</pre>
				<p>
Calls the SourceInAnimationDef(), SourceInControllerDef() and SourceInGeometryDef() methods in that order to find src.
</p>

				
				
			
				
				<h3 id="RefId.SourceInControllerDef">func (RefId) <a href="/target/refid.go?s=9776:9827#L368">SourceInControllerDef</a></h3>
				<pre>func (me RefId) SourceInControllerDef() (s *Source)</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.SourceInGeometryDef">func (RefId) <a href="/target/refid.go?s=10323:10372#L393">SourceInGeometryDef</a></h3>
				<pre>func (me RefId) SourceInGeometryDef() (s *Source)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.VisualSceneDef">func (RefId) <a href="/target/visualscene.gt.go?s=4438:4492#L148">VisualSceneDef</a></h3>
				<pre>func (me RefId) VisualSceneDef() (def *VisualSceneDef)</pre>
				<p>
Searches (all LibVisualSceneDefs contained in AllVisualSceneDefLibs) for the VisualSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
		
			
			
			<h2 id="RefParam">type <a href="/target/refsid.go?s=94:188#L1">RefParam</a></h2>
			<pre>type RefParam struct {
    <span class="comment">//	A parameter reference technically always refers to a Sid.</span>
    RefSid
}</pre>
			<p>
References a previously defined parameter.
</p>


			

			

			

			
				
				<h3 id="NewRefParam">func <a href="/target/refsid.go?s=408:456#L10">NewRefParam</a></h3>
				<pre>func NewRefParam(paramRef string) (rs *RefParam)</pre>
				<p>
Creates and returns a new RefParam initialized with the specified paramRef.
</p>

				
			

			
				
				<h3 id="RefParam.SetParamRef">func (*RefParam) <a href="/target/refsid.go?s=248:294#L5">SetParamRef</a></h3>
				<pre>func (me *RefParam) SetParamRef(sidRef string)</pre>
				<p>
Convenience short-hand for me.RefSid.SetSidRef(sidRef)
</p>

				
				
			
		
			
			
			<h2 id="RefSid">type <a href="/target/refsid.go?s=571:964#L17">RefSid</a></h2>
			<pre>type RefSid struct {
    <span class="comment">//	The Sid path currently referenced.</span>
    <span class="comment">//	To be set ONLY through the NewRefSid() constructor or SetSidRef() method!</span>
    S string

    <span class="comment">//	The resolved value referenced by this Sid path.</span>
    <span class="comment">//	This is always a pointer: so V may be a *SidFloat but it will never be a SidFloat.</span>
    <span class="comment">//	To be set ONLY through the Resolve() method! Reset to nil by the SetSidRef() method.</span>
    V interface{}
}</pre>
			<p>
References a resource by its scoped identifier (Sid).
</p>


			

			

			

			
				
				<h3 id="NewRefSid">func <a href="/target/refsid.go?s=1048:1090#L29">NewRefSid</a></h3>
				<pre>func NewRefSid(sidRef string) (rs *RefSid)</pre>
				<p>
Creates and returns a new RefSid, its S initialized with the specified sidRef.
</p>

				
			

			
				
				<h3 id="RefSid.Resolve">func (*RefSid) <a href="/target/refsid.go?s=2254:2308#L58">Resolve</a></h3>
				<pre>func (me *RefSid) Resolve(root RefSidRoot, force bool)</pre>
				<p>
If me.V is nil or force is true: resolves the Sid path in me.S and sets V to the result.
For possible root arguments, see RefSidRoot. If no match is found for the full path, V
will become nil (rather than, say, a partial-path-match result-value).
</p>
<p>
Sid path examples:
</p>
<pre>-	foo/bar/doodad
	either: root is a lib that finds object with Id &#34;foo&#34;, which resolves path &#34;bar/doodad&#34;
	or: root is a non-lib object with Id &#34;foo&#34; and resolves path &#34;bar/doodad&#34;
-	./bar/doodad
	root is a non-lib object with its own arbitrary Id and resolves path &#34;bar/doodad&#34;
-	bar
	gets rewritten to &#34;./bar&#34;, then: see above
-	foo/bar/doodad.Hollow
	root resolves foo/bar/doodad, then returns pointer to its Hollow field
	(if doodad supports named-field access by implementing RefSidFielder)
-	foo/bar/doodad(2)
	root resolves foo/bar/doodad, then returns pointer to a &#34;slot&#34; at index 2
	(if doodad supports indexed-slot access by implementing RefSidIndexer)
</pre>

				
				
			
				
				<h3 id="RefSid.SetSidRef">func (*RefSid) <a href="/target/refsid.go?s=1183:1225#L36">SetSidRef</a></h3>
				<pre>func (me *RefSid) SetSidRef(sidRef string)</pre>
				<p>
Sets S to sidRef and resets V to nil.
</p>

				
				
			
		
			
			
			<h2 id="RefSidFielder">type <a href="/target/refsid.go?s=4025:4100#L122">RefSidFielder</a></h2>
			<pre>type RefSidFielder interface {
    AccessField(fieldName string) interface{}
}</pre>
			<p>
Implemented by select types that embed HasSid to aid resolving Sid paths
with a tailing named-field accessor, as in &#34;some/sid/path.fieldName&#34;.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RefSidIndexer">type <a href="/target/refsid.go?s=4245:4312#L128">RefSidIndexer</a></h2>
			<pre>type RefSidIndexer interface {
    AccessIndex(i, j int) interface{}
}</pre>
			<p>
Implemented by select types that embed HasSid to aid resolving Sid paths
with a tailing indexed-slot accessor, as in &#34;some/sid/path(2)&#34;.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RefSidRoot">type <a href="/target/refsid.go?s=4698:4769#L139">RefSidRoot</a></h2>
			<pre>type RefSidRoot interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
This interface needs to be passed to the RefSid.Resolve() method to resolve a Sid path:
Implemented by almost all &#34;LibFooDefs&#34; types, plus all types that embed HasId and directly or
indirectly lead to fields of types that embed HasSid -- this includes almost all &#34;FooDef&#34; types.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Scene">type <a href="/target/common.go?s=7146:7550#L269">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Embodies the entire set of information that can be visualized from the contents of a resource.</span>
    Visual *VisualSceneInst

    <span class="comment">//	Embodies the entire set of information that can be articulated kinematically from a resource.</span>
    Kinematics *KxSceneInst

    <span class="comment">//	Specifies an environment in which physical objects are instantiated and simulated.</span>
    Physics []*PxSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a scene hierarchy or scene graph.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidBool">type <a href="/target/types.go?s=6612:6675#L301">SidBool</a></h2>
			<pre>type SidBool struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The value.</span>
    B bool
}</pre>
			<p>
A bool value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidFloat">type <a href="/target/types.go?s=6726:6793#L310">SidFloat</a></h2>
			<pre>type SidFloat struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The value.</span>
    F float64
}</pre>
			<p>
A float64 value that has a scoped identifier.
</p>


			

			

			

			
				
				<h3 id="SidF">func <a href="/target/assets.go?s=721:756#L25">SidF</a></h3>
				<pre>func SidF(f float64) (sf *SidFloat)</pre>
				<p>
Returns a ScopedFloat with the specified value and no Sid.
</p>

				
			

			
		
			
			
			<h2 id="SidFloat3">type <a href="/target/types.go?s=6850:6918#L319">SidFloat3</a></h2>
			<pre>type SidFloat3 struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The values.</span>
    F Float3
}</pre>
			<p>
Three float64 values that have a scoped identifier.
</p>


			

			

			

			

			
				
				<h3 id="SidFloat3.AccessIndex">func (*SidFloat3) <a href="/target/types.go?s=6990:7044#L329">AccessIndex</a></h3>
				<pre>func (me *SidFloat3) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="SidString">type <a href="/target/types.go?s=7115:7182#L334">SidString</a></h2>
			<pre>type SidString struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The value.</span>
    S string
}</pre>
			<p>
A string value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidVec3">type <a href="/target/types.go?s=7229:7292#L343">SidVec3</a></h2>
			<pre>type SidVec3 struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	X, Y, Z</span>
    unum.Vec3
}</pre>
			<p>
A 3D vector that has a scoped identifier.
</p>


			

			

			

			

			
				
				<h3 id="SidVec3.AccessField">func (*SidVec3) <a href="/target/types.go?s=7368:7421#L353">AccessField</a></h3>
				<pre>func (me *SidVec3) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;.
</p>

				
				
			
				
				<h3 id="SidVec3.AccessIndex">func (*SidVec3) <a href="/target/types.go?s=7615:7667#L367">AccessIndex</a></h3>
				<pre>func (me *SidVec3) AccessIndex(i, _ int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional indices 0 through 2.
</p>

				
				
			
		
			
			
			<h2 id="Source">type <a href="/target/source.go?s=126:424#L1">Source</a></h2>
			<pre>type Source struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Asset</span>
    HasAsset

    <span class="comment">//	Techniques</span>
    HasTechniques

    <span class="comment">//	The data array of this Source.</span>
    Array SourceArray

    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Describes a stream of values from this array data source.</span>
        Accessor *SourceAccessor
    }
}</pre>
			<p>
Declares a data repository that provides values
according to the semantics of an Input that refers to it.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SourceAccessor">type <a href="/target/source.go?s=485:1239#L19">SourceAccessor</a></h2>
			<pre>type SourceAccessor struct {
    <span class="comment">//	The number of times the array is accessed. Required.</span>
    Count uint64

    <span class="comment">//	The index of the first value to be read from the array. The default is 0. Optional.</span>
    Offset uint64

    <span class="comment">//	The Id of the array to access. Required.</span>
    Source RefId

    <span class="comment">//	The number of values that are to be considered a unit during each access to the array.</span>
    <span class="comment">//	The default is 1, indicating that a single value is accessed. Optional.</span>
    Stride uint64

    <span class="comment">//	The number and order of Params define the output of the accessor.</span>
    <span class="comment">//	Parameters are bound to values in the order in which both are specified. No reordering of the data can occur.</span>
    <span class="comment">//	A Param without a Name indicates that the value is not part of the output, so the Param is unbound.</span>
    Params []*Param
}</pre>
			<p>
Describes a stream of values from an array data source.
</p>


			

			

			

			
				
				<h3 id="NewSourceAccessor">func <a href="/target/source.go?s=1301:1346#L40">NewSourceAccessor</a></h3>
				<pre>func NewSourceAccessor() (me *SourceAccessor)</pre>
				<p>
Allocates, initializes and returns a new SourceAccessor.
</p>

				
			

			
		
			
			
			<h2 id="SourceArray">type <a href="/target/source.go?s=1509:2205#L47">SourceArray</a></h2>
			<pre>type SourceArray struct {
    <span class="comment">//	Id</span>
    HasId

    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	A slice into the array of bools that this Source represents, if any.</span>
    Bools []bool

    <span class="comment">//	A slice into the array of floats that this Source represents, if any.</span>
    Floats []float64

    <span class="comment">//	A slice into the array of RefIds that this Source represents, if any.</span>
    IdRefs []string

    <span class="comment">//	A slice into the array of ints that this Source represents, if any.</span>
    Ints []int64

    <span class="comment">//	A slice into the array of names that this Source represents, if any.</span>
    Names []string

    <span class="comment">//	A slice into the array of RefSids that this Source represents, if any.</span>
    SidRefs []string

    <span class="comment">//	A slice into the array of tokens that this Source represents, if any.</span>
    Tokens []string
}</pre>
			<p>
The data array of a Source.
Of all its []slice fields, only ONE should ever be non-nil/non-empty at any time.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Sources">type <a href="/target/source.go?s=2259:2290#L77">Sources</a></h2>
			<pre>type Sources map[string]*Source</pre>
			<p>
A hash-table of Sources, each keyed with its Id.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Technique">type <a href="/target/common.go?s=7662:7915#L285">Technique</a></h2>
			<pre>type Technique struct {
    <span class="comment">//	The type of profile. This is a vendor-defined character string</span>
    <span class="comment">//	that indicates the platform or capability target for the technique.</span>
    Profile string

    <span class="comment">//	Arbitrary XML content or meta-data for this Technique.</span>
    Data string
}</pre>
			<p>
Declares platform-specific or program-specific information
used to process some portion of the content.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Transform">type <a href="/target/transform.go?s=819:1683#L18">Transform</a></h2>
			<pre>type Transform struct {
    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	The type of this transformation (rotation, skewing, scaling, translation, &#34;look-at&#34;, or matrix).</span>
    <span class="comment">//	Must be one of the TransformKind* enumerated constants.</span>
    Kind TransformKind

    <span class="comment">//	Contains one or more vectors and values representing this transformation.</span>
    <span class="comment">//	For TransformKindLookat:</span>
    <span class="comment">//		9 values representing three 3D vectors (eye position, interest point, up-axis).</span>
    <span class="comment">//	For TransformKindMatrix:</span>
    <span class="comment">//		16 values representing one column-major 4x4 matrix.</span>
    <span class="comment">//	For TransformKindSkew:</span>
    <span class="comment">//		7 values -- one angle in degrees, then two 3D vectors for the axes of rotation and translation.</span>
    <span class="comment">//	For TransformKindRotate:</span>
    <span class="comment">//		4 values -- one 3D vector specifying the axis of rotation, then one angle in degrees.</span>
    <span class="comment">//	For TransformKindTranslate or TransformKindScale:</span>
    <span class="comment">//		3 values representing a single 3D vector.</span>
    F []float64
}</pre>
			<p>
Represents a single transformation of a specific kind.
</p>


			

			

			

			

			
				
				<h3 id="Transform.AccessField">func (*Transform) <a href="/target/transform.go?s=1802:1857#L42">AccessField</a></h3>
				<pre>func (me *Transform) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34; (mapped to the first three values in me.F).
</p>

				
				
			
				
				<h3 id="Transform.AccessIndex">func (*Transform) <a href="/target/transform.go?s=2068:2122#L56">AccessIndex</a></h3>
				<pre>func (me *Transform) AccessIndex(i, j int) interface{}</pre>
				<p>
RefSidIndexer implementation.
Supports one-dimensional and two-dimensional indices.
</p>

				
				
			
		
			
			
			<h2 id="TransformKind">type <a href="/target/transform.go?s=54:76#L1">TransformKind</a></h2>
			<pre>type TransformKind int</pre>
			<p>
Categorizes the kind of a Transform.
</p>


			
				<pre>const (
    <span class="comment">//	A position and orientation transformation suitable for aiming a camera.</span>
    TransformKindLookat TransformKind = iota + 1

    <span class="comment">//	A transformation that embodies mathematical changes to points within a coordinate system</span>
    <span class="comment">//	or the coordinate system itself.</span>
    TransformKindMatrix

    <span class="comment">//	A transformation that specifies how to rotate an object around an axis.</span>
    TransformKindRotate

    <span class="comment">//	A transformation that specifies how to deform an object along one axis.</span>
    TransformKindSkew

    <span class="comment">//	A transformation that specifies how to change an object&#39;s size.</span>
    TransformKindScale

    <span class="comment">//	A transformation that changes the position of an object in a local coordinate system.</span>
    TransformKindTranslate
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=1724:1973#L57">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	A scene graph containing nodes of visual information and related data.</span>
    Nodes []*NodeDef

    <span class="comment">//	Specifies how to evaluate this visual scene.</span>
    Evaluations []*VisualSceneEvaluation
}</pre>
			<p>
Embodies the entire set of information that can be visualized from the contents of a resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneDef.DefaultInst">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=2841:2904#L100">DefaultInst</a></h3>
				<pre>func (me *VisualSceneDef) DefaultInst() (inst *VisualSceneInst)</pre>
				<p>
Returns &#34;the default VisualSceneInst instance&#34; referencing this VisualSceneDef definition.
That instance is created once when this method is first called on me,
and will have its Def field readily set to me.
</p>

				
				
			
				
				<h3 id="VisualSceneDef.Init">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=1993:2025#L69">Init</a></h3>
				<pre>func (me *VisualSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="VisualSceneDef.NewInst">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=3221:3280#L110">NewInst</a></h3>
				<pre>func (me *VisualSceneDef) NewInst() (inst *VisualSceneInst)</pre>
				<p>
Creates and returns a new VisualSceneInst instance referencing this VisualSceneDef definition.
Any VisualSceneInst created by this method will have its Def field readily set to me.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneEvaluation">type <a href="/target/visualscene.gt.go?s=81:360#L1">VisualSceneEvaluation</a></h2>
			<pre>type VisualSceneEvaluation struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Whether evaluation is enabled. Disabling evaluation can be useful for debugging.</span>
    Disabled bool

    <span class="comment">//	Describes effects passes to render a scene.</span>
    RenderPasses []*VisualSceneRendering
}</pre>
			<p>
Declares information specifying how to evaluate a visual scene.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneEvaluation.AccessField">func (*VisualSceneEvaluation) <a href="/target/-gen-refsids.go?s=40218:40285#L1630">AccessField</a></h3>
				<pre>func (me *VisualSceneEvaluation) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;Disabled&#34;.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=2072:2388#L73">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst

    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default (unless created via Def.NewInst()) and meant to be set ONLY by</span>
    <span class="comment">//	the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *VisualSceneDef
}</pre>
			<p>
Instantiates a visual scene resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneInst.EnsureDef">func (*VisualSceneInst) <a href="/target/visualscene.gt.go?s=3664:3718#L121">EnsureDef</a></h3>
				<pre>func (me *VisualSceneInst) EnsureDef() *VisualSceneDef</pre>
				<p>
If me is &#34;dirty&#34; or me.Def is nil, sets me.Def to the correct VisualSceneDef
according to the current me.DefRef value (by searching AllVisualSceneDefLibs).
Then returns me.Def.
(Note, every VisualSceneInst&#39;s Def is nil initially, unless it was created via VisualSceneDef.NewInst().)
</p>

				
				
			
				
				<h3 id="VisualSceneInst.Init">func (*VisualSceneInst) <a href="/target/visualscene.gt.go?s=2408:2441#L84">Init</a></h3>
				<pre>func (me *VisualSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneRendering">type <a href="/target/visualscene.gt.go?s=412:917#L9">VisualSceneRendering</a></h2>
			<pre>type VisualSceneRendering struct {
    <span class="comment">//	Name</span>
    HasName

    <span class="comment">//	Sid</span>
    HasSid

    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Refers to a NodeDef that contains a camera describing</span>
    <span class="comment">//	the viewpoint from which to render this compositing step. Optional.</span>
    CameraNode RefId

    <span class="comment">//	Specifies which layer or layers to render in this compositing step while evaluating the scene.</span>
    Layers Layers

    <span class="comment">//	If set, specifies which effect to render in this compositing step while evaluating the scene.</span>
    MaterialInst *VisualSceneRenderingMaterialInst
}</pre>
			<p>
Describes one effect pass to evaluate a scene.
</p>


			

			

			

			
				
				<h3 id="NewVisualSceneRendering">func <a href="/target/visualscene.gt.go?s=934:991#L31">NewVisualSceneRendering</a></h3>
				<pre>func NewVisualSceneRendering() (me *VisualSceneRendering)</pre>
				<p>
Constructor
</p>

				
			

			
				
				<h3 id="VisualSceneRendering.AccessField">func (*VisualSceneRendering) <a href="/target/-gen-refsids.go?s=38820:38886#L1564">AccessField</a></h3>
				<pre>func (me *VisualSceneRendering) AccessField(fn string) interface{}</pre>
				<p>
RefSidFielder implementation.
Supported field names: &#34;CameraNode&#34;.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneRenderingMaterialInst">type <a href="/target/visualscene.gt.go?s=1108:1624#L37">VisualSceneRenderingMaterialInst</a></h2>
			<pre>type VisualSceneRenderingMaterialInst struct {
    <span class="comment">//	Extras</span>
    HasExtras

    <span class="comment">//	Binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding

    <span class="comment">//	Target specific techniques and passes inside a material</span>
    <span class="comment">//	rather than having to split the effects techniques and passes into multiple effects.</span>
    OverrideTechnique struct {
        <span class="comment">//	Specifies the Sid of a Technique</span>
        Ref RefSid

        <span class="comment">//	Specifies the Sid of one FxPass to execute.</span>
        <span class="comment">//	If not specified, then all of the Technique&#39;s passes are used.</span>
        Pass RefSid
    }
}</pre>
			<p>
Instantiates a material resource for a screen effect.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="pkgreflect/">pkgreflect</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="util/">util</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>